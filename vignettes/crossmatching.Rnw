%\VignetteEngine{knitr}
%\VignetteIndexEntry{Fragment matching using 'synapter'}
%\VignetteKeywords{Mass Spectrometry, Proteomics, Bioinformatics, quantitative, Ion mobility, label-free}
%\VignettePackage{synapter}

\documentclass[12pt,a4paper,english]{scrartcl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{tikz}
\usepackage{hyperref}
%\usepackage[authoryear,round]{natbib}
\usepackage[auth-sc]{authblk}
\usepackage{setspace}
\onehalfspacing

% caption formatting
\setcapindent{0em}
\setkomafont{captionlabel}{\sffamily\bfseries}
\setkomafont{caption}{\sffamily}

\renewcommand\Authands{ and }

\newcommand{\R}{\texttt{R} }
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\mbox{\normalfont\textsf{#1}}}}
\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%% colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\usepackage{geometry}
\geometry{verbose,
  tmargin = 2.5cm,
  bmargin = 2.5cm,
  lmargin = 3.0cm,
  rmargin = 3.0cm}

\usepackage{hyperref}
\usepackage{breakurl}
\hypersetup{%
  pdfusetitle,
  bookmarks = {true},
  bookmarksnumbered = {true},
  bookmarksopen = {true},
  bookmarksopenlevel = 2,
  unicode = {true},
  breaklinks = {false},
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}


\author{Sebastian Gibb
  \thanks{\email{mail@sebastiangibb.de}}
}

\author{Laurent Gatto%
  \thanks{\email{lg390@cam.ac.uk}}
}

\affil{
  Computational Proteomics Unit\\
  University of Cambridge
}

\begin{document}

\title{Fragment matching using \Rpackage{synapter} package}

\maketitle

%% Abstract and keywords %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 0.3in minus 0.1in
\hrule
\begin{abstract}
  This vignette describes how to apply fragment matching to
  MS$^E$/HDMS$^E$ data using the \Rpackage{synapter} package. The
  fragment matching feature allows one to rescue non unique matches
  and remove falsly assigned unique matches as well. 
\end{abstract}

\textit{Keywords}: Mass Spectrometry (MS), proteomics, bioinformatics,
IMS, ion mobility separation, ion mobility, Synapt, label free, data
independent acquisition, spectra similarity, fragment matching.

\vskip 0.1in minus 0.05in
\hrule
\vskip 0.2in minus 0.1in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\tableofcontents

<<knitr, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.align = "center",
               fig.height = 5,
               fig.show = "hold",
               stop_on_error = 1L,
               tidy = FALSE,
               par = TRUE,
               prompt = FALSE,
               comment = NA)
options(replace.assign = TRUE,
        width = 70)
@

<<setup, echo=FALSE>>=
library(xtable)
suppressPackageStartupMessages(library(synapter))
library(synapterdata)
@

\section{Introduction}

This document assumes familiarity with standard \Rpackage{synapter}
pipeline described in \citep{Bond2013} and in the package
\textit{synapter} vignette.

In this vignette we introduce the new fragment matching feature. This
feature improves the matching of identification and the quantitation
features. After applying the usual \Rfunction{synergise} workflow (see
\Rfunction{?synergise} and \Rfunction{?Synapter} for details) a number
of multiple matches and possible false unique matches remain that can
be deconvoluted by comparing common peaks in the quantitation fragment
peaks and the identification spectrum.

The example data \Robject{synobj2} is available in the
\Rpackage{synapterdata} package and can be directly load as follows:

<<loadsynobj2>>=
library("synapterdata")
data(synobj2)
@

In sections \ref{sec:synergise} and \ref{sec:spec}, we describe how
\Robject{synobj2} was generated. The test files used this vignette can
be downloaded from \href{TODO}. The following sections then describe
the new peak cross matching functionality.

\section{Running \Rfunction{synergise}}\label{sec:synergise}

One has to run the \Rfunction{synergize} workflow before fragment
matching can be applied. Please read the general \Rpackage{synapter}
vignette for the general use of \Rfunction{synergise}. 

<<create-synobj2, cache=FALSE, eval=TRUE, echo=FALSE>>=
cat(readLines(system.file(file.path("scripts", "create_synobj2.R"),
                          package="synapterdata"))[-c(11:18, 20:24)],
    sep = "\n")
@

\section{Loading the spectrum  and fragment data}\label{sec:spec}

The data needed for the fragment matching procedure are a
\code{Spectrum.xml} and a \code{final\_fragment.csv} file for the
identification and the quantitation run.

<<prepare-loadspectra, echo=FALSE, eval=TRUE, tidy=FALSE>>=
cat(readLines(system.file(file.path("scripts", "create_synobj2.R"),
                          package="synapterdata"))[c(11:18, 20:21)], sep = "\n")
@

\section{Filtering fragments}\label{sec:filtfrag}

This step is optional and allows one to remove low abundance fragments
in the spectra using the \Rfunction{filterFragments}. Filtering
fragments can remove noise in the spectra and reduce undesired
fragment matches. Prior to filtering, the
\Rfunction{plotCumulativeNumberOfFragments} function can be use to
visualize the intensity of all fragments. Both functions have a
\code{what} argument to decide what spectra/fragments to
filter/plot. Choose \code{spectrum.ident} for the identification
spectra, \code{spectrum.quant} for the quantitation spectra,
\code{fragments.ident} for the identification fragments and
\code{fragment.quant} for the quantitation fragments.

<<filterfragments>>=
plotCumulativeNumberOfFragments(synobj2, what = "spectrum.quant")
filterFragments(synobj2, what = "spectrum.quant", minIntensity = 70,
                verbose = FALSE)

plotCumulativeNumberOfFragments(synobj2, what = "fragments.ident")
filterFragments(synobj2, what = "fragments.ident", minIntensity = 70,
                verbose = FALSE)
@

\section{Cross matching}\label{sec:crossm}

This method compares, named \Rfunction{crossMatching} performs
multiple comparisons:

\begin{itemize}

\item identification spectra vs the quantitation fragments
  (\code{spectrum.identXfragments.quant}),

\item the quantitation spectra vs the identification fragments
  (\code{spectrum.quantXfragments.ident})

\item the identification vs the quantitation fragments
  (\code{fragments.identXfragments.quant}).

\end{itemize}


Because the peaks/fragments in the spectra of one run will never be
numerically identical to these in another, a tolerance parameter has
to be set using the \Rfunction{setCrossMatchingPpmTolerance}
function. Peaks/Fragments within this tolerance are treated as
identical.

<<cx>>=
setCrossMatchingPpmTolerance(synobj2, 25)
crossMatching(synobj2, verbose = FALSE)
@

The \Rfunction{plotCrossMatching} function illustrates the details of
this cross matching procedure. If it is called without any additional
argument every cross matching is plotted. One can use the \code{key}
argument to select a special value in a column (defined by the
\code{column} argument) of the \code{MatchedEMRTs} data.frame. E.g. if
one wants to select the cross matching results with a high number of
common peaks, e.g. 22 common peaks:

<<plotcx22>>=
plotCrossMatching(synobj2, key = 22, column = "spectrum.quantXfragments.ident",
                  verbose = FALSE)
@

Or, if one is interested in all results for the peptide with the
sequence \code{"TALIDGLAQR"}.

<<plotcxseq>>=
plotCrossMatching(synobj2, key = "TALIDGLAQR", column = "peptide.seq",
                  verbose = FALSE)
@

Maybe the peptide with a special precursor ID looks interesting.

<<plotcxid>>=
plotCrossMatching(synobj2, key = 12589, column = "precursor.leID.ident",
                  verbose = FALSE)
@

\section{Plot distribution of common peaks}\label{sec:plotperf}

You could use \Rfunction{plotCrossMatchingPerformance} to get an idea how well
the cross matching works and what are the results if you will filter the
\code{MatchedEMRT} data.frame by the number of common peaks.\\
This function returns a list with a matrix containing true-positive,
false-positive, true-negative and false-negative matches for the unique and non
unique matches.

<<plotcxperformance>>=
m <- plotCrossMatchingPerformance(synobj2)
@

<<confusionmatrixunique, results="asis">>=
xtable(m$unique[1:15,], row.names=FALSE)
@

<<confusionmatrixnonunqiue, results="asis">>=
xtable(m$nonunique[1:15,], row.names=FALSE)
@

\section{Filter unique matches}

From the left panel of the plot shown in section \ref{sec:plotperf} and the
table of unique matches it is obvious that you can easily reduce the number of
false matches by applying a rules that true matches must have at least one
peak/fragment in common. Clearly this will also remove some true matches. The
question is whether you want to rely on matches that have no (or only a few)
peaks/fragments in common?

<<filerunique>>=
performance(synobj2)
getEMRTtable(synobj2)
filterUniqueMatches(synobj2, minNumber = 1)
performance(synobj2)
getEMRTtable(synobj2)
@

\section{Filter non-unique matches}

The largest potential offers the cross matching for non unique matches. If we
consider the match with the highest number of common peaks/fragments as true
match we will win a lot of new unique matches that could not resolved before
(c.f. section \ref{sec:plotperf}).
You could filter the non unique matches by the difference of common peaks from
the highest to the second highest number in the match group. E.g. we have two
different match groups. In the first group we have two possible matches: a match
with 7 and a match with 2 fragments in common. In the other group there are a
matches with 2 and 1 fragments in common. If we decide to accept a difference
of at least 2 the one with 7 common peaks will turn into an unique match and all
other matches will be removed (marked as no match). To choose a good threshold
for the difference look at the right panel of the plot generated in section
\ref{sec:plotperf} and the corresponding table.
In the following example we rescue 289 unique matches out of the non unique
ones.

<<filernonunique>>=
performance(synobj2)
getEMRTtable(synobj2)
filterNonUniqueMatches(synobj2, minDelta = 2)
performance(synobj2)
getEMRTtable(synobj2)
@


\section{Exporting results}

Like in the normal \Rpackage{synapter} workflow you can export the
\code{MatchedEMRT} data.frame using the \Rfunction{writeMatchedEMRTs} function.
The table has some new columns that correspond to the cross matching procedure,
e.g. \code{spectrum.identXfragments.quant},
\code{spectrum.quantXfragments.ident}, \code{fragments.identXfragments.quant}
and so on.
<<export, eval=FALSE>>=
writeMatchedEMRTs(synobj2, file = "MatchedEMRTs.csv", what = "full")
@

\section{Session information}\label{sec:sessionInfo}

All software and respective versions used to produce this document are
listed below.

<<sessioninfo, results='asis', echo=FALSE, cache=FALSE>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{synapter}

\end{document}

