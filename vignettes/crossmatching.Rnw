%\VignetteEngine{knitr}
%\VignetteIndexEntry{Fragment matching using 'synapter'}
%\VignetteKeywords{Mass Spectrometry, Proteomics, Bioinformatics, quantitative, Ion mobility, label-free}
%\VignettePackage{synapter}

\documentclass[12pt,a4paper,english]{scrartcl}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[authoryear,round]{natbib}
\usepackage[auth-sc]{authblk}
\usepackage{setspace}
\onehalfspacing

% caption formatting
\setcapindent{0em}
\setkomafont{captionlabel}{\sffamily\bfseries}
\setkomafont{caption}{\sffamily}

\renewcommand\Authands{ and }

\newcommand{\R}{\texttt{R} }
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\mbox{\normalfont\textsf{#1}}}}
\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
%% colors
\definecolor{Red}{rgb}{0.7,0,0}
\definecolor{Blue}{rgb}{0,0,0.8}

\usepackage{geometry}
\geometry{verbose,
  tmargin = 2.5cm,
  bmargin = 2.5cm,
  lmargin = 3.0cm,
  rmargin = 3.0cm}

\usepackage{hyperref}
\usepackage{breakurl}
\hypersetup{%
  pdfusetitle,
  bookmarks = {true},
  bookmarksnumbered = {true},
  bookmarksopen = {true},
  bookmarksopenlevel = 2,
  unicode = {true},
  breaklinks = {false},
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}


\author{Sebastian Gibb%
  \thanks{\email{mail@sebastiangibb.de}}
}

\author{Pavel V. Shliaha
}

\author{Laurent Gatto%
  \thanks{\email{lg390@cam.ac.uk}}
}

\affil{
  Computational Proteomics Unit\\
  University of Cambridge
}

\begin{document}

\title{Fragment matching using the \Rpackage{synapter} package}

\maketitle

%% Abstract and keywords %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 0.3in minus 0.1in
\hrule
\begin{abstract}
  This vignette describes how to apply fragment matching to
  MS$^E$/HDMS$^E$ data using the \Rpackage{synapter} package. The
  fragment matching feature allows one to rescue non unique matches
  and remove falsely assigned unique matches as well.
\end{abstract}

\textit{Keywords}: Mass Spectrometry (MS), proteomics, bioinformatics,
IMS, ion mobility separation, ion mobility, Synapt, label free, data
independent acquisition, spectra similarity, fragment matching.

\vskip 0.1in minus 0.05in
\hrule
\vskip 0.2in minus 0.1in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\tableofcontents

\newpage

<<knitr, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.align = "center",
               fig.height = 5,
               fig.show = "hold",
               stop_on_error = 1L,
               tidy = FALSE,
               par = TRUE,
               prompt = FALSE,
               comment = NA)
options(replace.assign = TRUE,
        width = 70)
@

<<setup, echo=FALSE>>=
library(xtable)
suppressPackageStartupMessages(library(synapter))
library(synapterdata)
data(synobj2)
@

\section{Introduction}

This document assumes familiarity with standard \Rpackage{synapter}
pipeline described in \cite{Bond2013} and in the package
\textit{synapter} vignette, available
online\footnote{\url{http://www.bioconductor.org/packages/devel/bioc/html/synapter.html}}
and with \Rfunction{vignette("synapter", package = "synapter")}.

\bigskip

In this vignette we introduce a new fragment matching feature (see
figures \ref{fig:xm1}, \ref{fig:xm2} and \ref{fig:xm3}), which
improves the matching of identification and the quantitation
features. After applying the usual \Rfunction{synergise} workflow (see
\Rfunction{?synergise} and \Rfunction{?Synapter} for details) a number
of multiple matches and possible false unique matches remain that can
be deconvoluted by comparing common peaks in the identification fragment
peaks and the quantitation spectra.

The example data \Robject{synobj2} used throughout this document is
available in the \Rpackage{synapterdata} package and can be directly
load as follows:

<<loadsynobj2, eval=FALSE>>=
library("synapterdata")
data(synobj2)
@

In sections \ref{sec:synergise} and \ref{sec:spec}, we describe how
\Robject{synobj2} was generated. The test files used in this vignette
can be downloaded from
\url{http://proteome.sysbiol.cam.ac.uk/lgatto/synapter/data/}. The
following sections then describe the new peak cross matching
functionality.

\section{Running \Rfunction{synergise}}\label{sec:synergise}

One has to run the \Rfunction{synergise} workflow before fragment
matching can be applied. Please read the general \Rpackage{synapter}
vignette for the general use of \Rfunction{synergise}.

<<create-synobj2, cache=FALSE, eval=TRUE, echo=FALSE>>=
cat(readLines(system.file(file.path("scripts", "create_synobj2.R"),
                          package="synapterdata"))[-c(11:18, 20:24)],
    sep = "\n")
@

\section{Loading the fragment and spectra data}\label{sec:spec}

The data needed for the fragment matching procedure are a
\code{final\_fragment.csv} file for the identification run and
a \code{Spectrum.xml} file for the quantitation run.

<<prepare-loadspectra, echo=FALSE, eval=TRUE, tidy=FALSE>>=
cat(readLines(system.file(file.path("scripts", "create_synobj2.R"),
                          package="synapterdata"))[c(11:18, 20:21)], sep = "\n")
@

\section{Filtering fragments}\label{sec:filtfrag}

This step is optional and allows one to remove low abundance fragments
in the spectra using the \Rfunction{filterFragments}. Filtering
fragments can remove noise in the spectra and reduce undesired
fragment matches. Prior to filtering, the \\
\Rfunction{plotCumulativeNumberOfFragments} function can be use to
visualise the intensity of all fragments. Both functions have a
\code{what} argument to decide what spectra/fragments to
filter/plot. Choose \code{fragments.ident} for the identification
fragments and \code{spectra.quant} for the quantitation fragments.

<<filterfragmentsplot>>=
plotCumulativeNumberOfFragments(synobj2, what = "fragments.ident")
plotCumulativeNumberOfFragments(synobj2, what = "spectra.quant")
@

<<filterfragments, cache=TRUE>>=
filterFragments(synobj2, what = "fragments.ident", minIntensity = 70,
                verbose = FALSE)
filterFragments(synobj2, what = "spectra.quant", minIntensity = 70,
                verbose = FALSE)
@


\section{Cross matching}\label{sec:crossm}

This method compares, named \Rfunction{crossMatching} performs the matching of
the identification fragments vs the quantitation spectra and counts the number
of identical peaks for each combination.
multiple comparisons:

Because the peaks/fragments in the spectra of one run will never be
numerically identical to these in another, a tolerance parameter has
to be set using the \Rfunction{setCrossMatchingPpmTolerance}
function. Peaks/Fragments within this tolerance are treated as
identical.

<<cx>>=
setCrossMatchingPpmTolerance(synobj2, 25)
crossMatching(synobj2, verbose = FALSE)
@

The \Rfunction{plotCrossMatching} function illustrates the details of
this cross matching procedure. If it is called without any additional
argument every cross matching is plotted. One can use the \code{key}
argument to select a special value in a column (defined by the
\code{column} argument) of the \code{MatchedEMRTs} data.frame. E.g. if
one wants to select the cross matching results with a high number of
common peaks, e.g. 28 common peaks:

\begin{figure}[!hbt]
  \begin{center}
<<plotcx22, dev ='pdf', fig.widht=10, fig.height=5>>=
plotCrossMatching(synobj2, key = 28,
                  column = "CrossMatching",
                  verbose = FALSE)
@
\caption{Fragment matching for cases with 28 common fragments. The
  identification data are shown on the top (blue) and the quantitation
  data are on the bottom (red). Common peaks are displayed in darker colours
  and highlighted by full points.}
    \label{fig:xm1}
  \end{center}
\end{figure}


Or, if one is interested in all results for the peptide with the
sequence \code{"TALIDGLAQR"}.

\begin{figure}[!hbt]
  \begin{center}
<<plotcxseq, dev ='pdf', fig.widht=10, fig.height=5>>=
plotCrossMatching(synobj2,
                  key = "TALIDGLAQR", column = "peptide.seq",
                  verbose = FALSE)
@
\caption{Fragment matching for peptide \code{TALIDGLAQ}. }
    \label{fig:xm2}
  \end{center}
\end{figure}

Maybe the peptide with a special precursor ID looks interesting.

\begin{figure}[!hbt]
  \begin{center}
<<plotcxid, dev ='pdf', fig.widht=10, fig.height=5>>=
plotCrossMatching(synobj2,
                  key = 12589, column = "precursor.leID.ident",
                  verbose = FALSE)
@
\caption{Fragment matching precursor with \texttt{leID} identifier
  12589. }
    \label{fig:xm3}
  \end{center}
\end{figure}

\section{Plot distribution of common peaks}\label{sec:plotperf}

The \Rfunction{plotCrossMatchingPerformance} function can be used to
assess the performance of the cross matching and the result of the
filtering procedure (see below) based on the number of common
peaks. This function invisibly returns a list with matrices containing
true positive, false positive, true negative and false negative
matches for the unique and non unique matches EMRT matches, as
illustrated in tables \ref{tab:unique} and \ref{tab:multiple}.

\begin{figure}[!hbt]
  \begin{center}
<<plotcxperformance, dev='pdf', fig.widht=8, fig.height=4>>=
m <- plotCrossMatchingPerformance(synobj2)
@
\caption{Number of true/false match peptides for different peak
  matching thresholds and difference in number of peaks between the
  first and second (in terms of number of common peaks) possible
  matches. The former metric is used to filter out possible false
  positive unique matches while the second is used to filter multiple
  matches. Empty circles indicate zero peptides. }
    \label{fig:xmplot}
  \end{center}
\end{figure}

<<confusionmatrixunique, results="asis", echo=FALSE>>=
xtable(m$unique[1:15,], row.names=FALSE,
       caption="Number of true positives, false negatives, false positives, false negatives and false discovery rate for a given number of common peaks",
       label = "tab:unique")
@

<<confusionmatrixnonunqiue, results="asis", echo=FALSE>>=
xtable(m$nonunique[1:15,], row.names=FALSE,
       caption="Number of true positives, false negatives, false positives, false negatives and false discovery rate for a given difference in number of common peaks between the higest and second highest multiply matching EMRTs in terms of number of common peptides.",
       label="tab:multiple")
@

\clearpage

\section{Filtering unique matches}\label{sec:unique}

From the left panel on figure \ref{fig:xmplot} and table
\ref{tab:unique} displaying counts for unique matches one can define
filtering values for the unique (this section) and multiple matches
(next section). In the case of uniquely matching EMRTs, one can easily
reduce the number of false matches by requiring that true matches
must have at least one peak/fragment in common. Clearly this will also
remove some true matches. The question is whether you want to rely on
matches that have no (or only a few) peaks/fragments in common?

<<filerunique>>=
performance(synobj2)
getEMRTtable(synobj2)
filterUniqueMatches(synobj2, minNumber = 1)
performance(synobj2)
getEMRTtable(synobj2)
@

\section{Filtering non-unique matches}\label{sec:multiple}

The largest benefit of cross matching peaks is for non unique
matches. If we assume that true match have a highest number of common
peaks/fragments, we can distinguish correct matches among multiple
possible matches that could not resolved before (c.f. section
\ref{sec:plotperf}). To do so, we use the difference of common peaks
from the highest to the second highest number in the match
group. Assuming two cases with multiple matches. In the first case, we
have two possible matches: a match with 7 and a match with 2 fragments
in common. In the second ambiguous match, there are a matches with 2
and 1 fragments in common respectively. If we decide to accept a
difference of at least 2, our first multiple match case be resolved
into a unique match as the difference between the best and second
matches is 5 and the best match with 7 common fragments will be
upgraded to a unique match.

The right panel of figure \ref{fig:xmplot} and table
\ref{tab:multiple} can be used to choose a good threshold for the
difference in number of common peaks. In the following example we
rescue 289 unique matches out of the non unique ones.

<<filernonunique>>=
performance(synobj2)
getEMRTtable(synobj2)
filterNonUniqueMatches(synobj2, minDelta = 2)
performance(synobj2)
getEMRTtable(synobj2)
@


\section{Exporting results}

Like in the initial \Rpackage{synapter} workflow, it is possible to
export the \code{MatchedEMRT} results using the
\Rfunction{writeMatchedEMRTs} function.  The table has some new
columns that correspond to the cross matching procedure,
e.g. \code{CrossMatching}, \ldots.

<<export, eval=FALSE>>=
writeMatchedEMRTs(synobj2, file = "MatchedEMRTs.csv", what = "full")
@

\clearpage

\section{Session information}\label{sec:sessionInfo}

All software and respective versions used to produce this document are
listed below.

<<sessioninfo, results='asis', echo=FALSE, cache=FALSE>>=
toLatex(sessionInfo())
@

\bibliographystyle{plainnat}
\bibliography{synapter}

\end{document}

