#' filter Neutral Loss
#' @param df data.frame (needs a column Neutral.LossType)
#' @return a data.frame that contains only rows with Neutral.LossType == "None"
.filterNeutralLoss <- function(df) {
  return(df[which(df$Neutral.LossType == "None"), ])
}

#' read final_fragments.csv
#' @param file file path
#' @param removeNeutralLoss remove rows with neutral loss != "none"?
#' @param verbose verbose output?
#' @return a data.frame
.readFragements <- function(file, removeNeutralLoss=FALSE, verbose=TRUE) {
  stopifnot(file.exists(file))

  if (verbose) {
    message("Reading ", file)
  }

  df <- read.csv(file, stringsAsFactors=FALSE)

  if (removeNeutralLoss) {
    return(.filterNeutralLoss(df))
  } else {
    return(df)
  }
}

#' read final_fragment.csv and turn data into MSnbase::Spectrum2 objects
#' @param df corresponding df from the synapter object ({Ident,Quant}PeptideData)
#' @param file filename
#' @param prefix character, prefix for the keyvalue in assaydata
#' (e.g.,"ident.spectra")
#' @param assaydata environment
#' @param storeAll should all spectra stored? or only the needed ones?
#' @param fileId integer, optional
#' @param removeNeutralLoss remove rows with neutral loss != "none"?
#' @param verbose verbose output
#' @return modified assaydata
.finalFragment2spectra <- function(df, file, prefix, assaydata, storeAll=TRUE,
                                   fileId=0, removeNeutralLoss=TRUE,
                                   verbose=TRUE) {
  stopifnot(!missing(prefix))

  fragments <- .readFragements(file, removeNeutralLoss=removeNeutralLoss,
                               verbose=verbose)

  assignments <- new.env(hash=TRUE, parent=emptyenv())
  idx <- split(1:nrow(fragments), f=fragments$precursor.leID)
  idx_keys <- names(idx)

  for (i in seq(along=idx)) {
    assign(idx_keys[i], idx[[i]], envir=assignments)
  }

  if (storeAll) {
    uleID <- unique(fragments$precursor.leID)
  } else {
    uleID <- intersect(df$precursor.leID, fragments$precursor.leID)
  }

  if (verbose) {
    message("Convert spectra data.frames to MSnbase::Spectrum2 objects")
    pb <- txtProgressBar(0, length(uleID), style=3)
  }

  keys <- paste(prefix, uleID , sep=":")
  fragment_keys <- paste("fragment.str", prefix, uleID, sep=":")
  sequence_keys <- paste("peptide.seq", prefix, uleID, sep=":")

  for (i in seq(along=uleID)) {
    assign(keys[i],
           .createMs2SpectrumFromFragments(uleID[i],
                                           fragments=fragments,
                                           assignments=assignments,
                                           fileId=fileId),
           envir=assaydata)
    assign(fragment_keys[i],
           .getFragmentStrFromFragments(uleID[i], fragments=fragments,
                                        assignments=assignments),
           envir=assaydata)
    assign(sequence_keys[i],
           .getPeptideSeqFromFragments(uleID[i], fragments=fragments,
                                       assignments=assignments),
           envir=assaydata)
    if (verbose) {
      setTxtProgressBar(pb, i)
    }
  }
  if (verbose) {
    close(pb)
  }
  return(assaydata)
}

#' fetch fragment.str in correct order
#' @param leID precursor.leID
#' @param fragments data.frame generated by readFragments
#' @param assignments env
#' @return character vector
.getFragmentStrFromFragments <- function(leID, fragments, assignments) {
  key <- as.character(leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(fragments$fragment.str[i][order(fragments$product.mhp[i])])
  } else {
    return(character())
  }
}

#' fetch peptide.seq
#' @param leID precursor.leID
#' @param fragments data.frame generated by readFragments
#' @param assignments env
#' @return character vector
.getPeptideSeqFromFragments <- function(leID, fragments, assignments) {
  key <- as.character(leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(fragments$peptide.str[i[1]])
  } else {
    return(character())
  }
}


