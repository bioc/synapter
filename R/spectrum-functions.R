#' parse synapter Spectrum.xml files
#'
#' Stupid parser for one of the ugliest pseudo-xml formats I have ever seen.
#'
#' @param file file path
#' @param ms1 should we read ms1 spectra?
#' @param encoding file encoding, seems to be windows specific
#' @param verbose verbose output?
#'
#' @return a list of length == 3; names: ms1, m2, assignments
#'  ms1: matrix of ms1 spectra information
#'  ms2: matrix of ms2 spectra information
#'  assignments: environment (key == leID), values == he_id
#'
.readSynapterSpectrumXml <- function(file, ms1=FALSE,
                                     encoding="Windows-1252",
                                     verbose=TRUE) {
  stopifnot(file.exists(file))

  ## helper functions
  .extractName <- function(x) {
    gsub("^.*NAME=\\\"([[:alpha:]_]+)\\\".*$", "\\1", x)
  }
  .extractLEID <- function(x) {
    gsub("^.*LE_ID=\\\"([[:digit:]]+)\\\".*$", "\\1", x)
  }
  .extractHEID <- function(x) {
    gsub("^.*HE_ID=\\\"([[:digit:],]+)\\\".*$", "\\1", x)
  }

  .createMsMatrix <- function(x, header) {
    ms <- do.call(rbind, strsplit(x, "[[:space:]]+"))
    ms <- ms[, -1]
    mode(ms) <- "double"
    colnames(ms) <- header
    return(ms)
  }

  if (verbose) {
    message("Reading ", file)
  }
  content <- readLines(file, encoding=encoding, warn=FALSE)

  if (verbose) {
    message("Search line numbers for Header information")
  }
  linesField <- grep("<FIELD", content, fixed=TRUE)
  splitPoint <- which(diff(linesField) > 1)
  linesFieldMs1 <- linesField[1:splitPoint]
  linesFieldMs2 <- linesField[(splitPoint+1):length(linesField)]

  if (verbose) {
    message("Read Header information")
  }

  header1 <- .extractName(content[linesFieldMs1])
  header2 <- .extractName(content[linesFieldMs2])

  if (ms1) {
    if (verbose) {
      message("Search line numbers for MS1 Data")
    }
    linesMs1 <- c(grep("<DATA", content, fixed=TRUE)+1,
                  grep("</DATA", content, fixed=TRUE)-1)
  }

  if (verbose) {
    message("Search line numbers for MS2 Data")
  }
  linesMs2 <- c(grep("<HE_DATA", content, fixed=TRUE)+1,
                grep("</HE_DATA", content, fixed=TRUE)-1)


  if (ms1) {
    if (verbose) {
      message("Read MS1 Data (", paste(linesMs1, collapse=":"), ")")
    }
    range <- seq(linesMs1[1], linesMs1[2])
    ms1 <- .createMsMatrix(content[range], header1)
  } else {
    ms1 <- matrix()
  }

  if (verbose) {
    message("Read MS2 Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesMs2[1], linesMs2[2])
  ms2 <- .createMsMatrix(content[range], header2)

  if (verbose) {
    message("Search line numbers for MS1 to MS2 assignment")
  }
  linesAssignment <- c(grep("<PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)+1,
                       grep("</PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)-1)

  if (verbose) {
    message("Read Assignment Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesAssignment[1], linesAssignment[2])

  le_ids <- .extractLEID(content[range])
  he_ids <- lapply(utils.ssv2list(.extractHEID(content[range]), sep=","), as.numeric)

  assignments <- new.env(hash=TRUE, parent=emptyenv(), size=length(le_ids))
  for (i in seq(along=le_ids)) {
    assign(le_ids[i], he_ids[[i]], envir=assignments)
  }

  return(list(ms1=ms1, ms2=ms2, assignments=assignments))
}

#' read spectrum.xml and turn data into MSnbase::Spectrum2 objects
#' @param df corresponding df from the synapter object ({Ident,Quant}PeptideData)
#' @param file filename
#' @param prefix character, prefix for the keyvalue in assaydata
#' (e.g.,"ident.spectra")
#' @param assaydata environment
#' @param fileId integer, optional
#' @param verbose verbose output
#' @return modified assaydata
.spectrumXml2spectra <- function(df, file, prefix, assaydata, fileId=0,
                                 verbose=TRUE) {
  stopifnot(!missing(prefix))

  xml <- .readSynapterSpectrumXml(file, ms1=FALSE, verbose=verbose)

  peptideinfo <- df[!duplicated(df$precursor.leID), ]
  keys <- paste(prefix, df$precursor.leID, sep=":")

  if (verbose) {
    message("Convert spectra data.frames to MSnbase::Spectrum2 objects")
    pb <- txtProgressBar(0, nrow(peptideinfo), style=3)
  }

  for (i in 1:nrow(peptideinfo)) {
    assign(keys[i],
           .createMs2SpectrumFromSpectrumXml(peptideinfo[i, ], xml$ms2,
                                             xml$assignments, fileId=fileId),
           envir=assaydata)

    if (verbose) {
      setTxtProgressBar(pb, i)
    }
  }
  if (verbose) {
    close(pb)
  }
  return(assaydata)
}

#' create MS2 spectrum from spectrum.xml data
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData
#' @param ms2 ms2 matrix generated by .readSynapterSpectrumXml
#' @param assignments env generated by .readSynapterSpectrumXml
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMs2SpectrumFromSpectrumXml <- function(peptideinfo, ms2, assignments,
                                              fileId=0) {
  key <- as.character(peptideinfo$precursor.leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(.createMsnbaseSpectrum2(peptideinfo=peptideinfo,
                                   mass=ms2[i, "Mass"],
                                   intensity=ms2[i, "Intensity"],
                                   fileId=fileId))
  } else {
    return(.createEmptyMsnbaseSpectrum2())
  }
}

#' create MS2 spectrum from final_fragment.csv data
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData
#' @param fragments data.frame generated by readFragments
#' @param assignments env
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMs2SpectrumFromFragments <- function(peptideinfo, fragments, assignments,
                                            fileId=0) {
  key <- as.character(peptideinfo$precursor.leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(.createMsnbaseSpectrum2(peptideinfo=peptideinfo,
                                   mass=fragments$product.mhp[i],
                                   intensity=fragments$product.inten[i],
                                   fileId=fileId))
  } else {
    return(.createEmptyMsnbaseSpectrum2())
  }
}

#' create an instance of an MSnbase::Spectrum2 object
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData or
#' final_fragment.csv
#' @param mass mass/mz
#' @param intensity intensity
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMsnbaseSpectrum2 <- function(peptideinfo, mass, intensity, fileId=0) {
  ## just to be sure, you can't trust any information in the csv/xml files
  o <- order(mass)
  new("Spectrum2",
      precScanNum=as.integer(peptideinfo$precursor.leID),
      precursorMz=peptideinfo$precursor.mhp,
      precursorIntensity=peptideinfo$precursor.inten,
      precursorCharge=peptideinfo$precursor.z,
      rt=peptideinfo$precursor.retT,
      centroided=TRUE,
      # tic=precursor.inten,
      peaksCount=length(mass),
      acquisitionNum=as.integer(peptideinfo$precursor.leID),
      mz=mass[o], intensity=intensity[o],
      fromFile=as.integer(fileId))
}

#' create an empty instance of an MSnbase::Spectrum2 object
#' @return Spectrum2 object
.createEmptyMsnbaseSpectrum2 <- function() {
  new("Spectrum2")
}

#' same functinality like "get" but returns an empty spectrum if the key could
#' not found
#' @param key character, key
#' @param envir env
#' @return Spectrum2 object
.getSpectrum <- function(key, envir) {
  if (exists(key, envir=envir)) {
    return(get(key, envir=envir))
  } else {
    return(.createEmptyMsnbaseSpectrum2())
  }
}

#' common peaks
#' @param x spectrum1 (MSnbase::Spectrum2)
#' @param y spectrum2 (MSnbase::Spectrum2)
#' @param tolerance double, allowed deviation
#' @return double, number of common peaks
.commonPeaks <- function(x, y, tolerance=25e-6) {
  mx <- mz(x)
  my <- mz(y)

  if (length(mx) == 0 || length(my) == 0) {
    return(0)
  } else if (length(mx) == 1) {
    return(sum(abs(mx-my)/my < tolerance))
  }

  ## adopted from MALDIquant:::.which.closest
  ## find left interval
  lIdx <- findInterval(my, mx, rightmost.closed=FALSE, all.inside=TRUE)
  ## find right interval
  rIdx <- lIdx+1L

  ## calculate relative differences for left and right nearest point
  lDiff <- abs(mx[lIdx]-my)/mx[lIdx]
  rDiff <- abs(mx[rIdx]-my)/mx[rIdx]

  return(sum(pmin(lDiff, rDiff) < tolerance))
}

#' plot identification vs quantitation spectra/fragments
#' @param ident matrix, spectrum 1
#' @param ident.metadata named character vector (is plotted as legend)
#' @param quant matrix, spectrum 2
#' @param quant.named character vector (is plotted as legend)
#' @param ident.norm double, normalisation factor
#' @param quant.norm double, normalisation factor
#' @param main title
#' @param xlab label for x-axis
#' @param ylab label for y-axis
#' @param legend.cex cex for legend text
#' @return double, number of common peaks
.plotIdentVsQuantSpectra <- function(ident, ident.metadata,
                                     quant, quant.metadata,
                                     ident.norm=1, quant.norm=1,
                                     ident.fragment.str, quant.fragment.str,
                                     main="", xlab="mhp", ylab="intensity",
                                     legend.cex=1, fragment.str.cex=0.5) {

  ident[, 2] <- ident[, 2]/ident.norm
  quant[, 2] <- quant[, 2]/quant.norm

  xlim <- c(min(c(ident[ident[, 2] > 0, 1],
                  quant[quant[, 2] > 0, 1], 0), na.rm=TRUE),
            max(c(ident[ident[, 2] > 0, 1],
                  quant[quant[, 2] > 0, 1],
                  0), na.rm=TRUE))

  ylim <- c(-max(c(ident[, 2], quant[, 2], 0), na.rm=TRUE),
             max(c(ident[, 2], quant[, 2], 0), na.rm=TRUE))

  plot(ident[,1], ident[,2], type="h", col=1,
       main=main, xlab=xlab, ylab=ylab,
       xlim=xlim, ylim=ylim)
  if (!missing(ident.fragment.str) && length(ident.fragment.str)) {
    text(ident[, 1], ident[, 2], ident.fragment.str, adj=c(0.5, 0),
         cex=fragment.str.cex, col=1)
  }
  lines(quant[,1], -quant[,2], type="h", col=2)
  if (!missing(quant.fragment.str) && length(quant.fragment.str)) {
    text(quant[, 1], -quant[, 2], quant.fragment.str, adj=c(0.5, 1),
         cex=fragment.str.cex, col=2)
  }
  abline(h=0, col="#808080")

  ident.legend <- paste(names(ident.metadata), ident.metadata, sep=":",
                        collapse=", ")
  quant.legend <- paste(names(quant.metadata), quant.metadata, sep=":",
                        collapse=", ")
  legend("topleft",
         legend=paste("ident:", ident.legend), bty="n", cex=legend.cex)
  legend("bottomleft",
             legend=paste("quant:", quant.legend), bty="n", cex=legend.cex)
}

#' readSpectraAndFragments
#' @param obj synapter object
#' @param filenames named list of filenames list(identspectrum, quantspectrum,
#' @param removeNeutralLoss remove rows with neutral loss != "none"?
#' @param verbose verbose output?
#' @return  env with MSnbase::Spectrum2 objects
readSpectraAndFragments <- function(obj, filenames, removeNeutralLoss=TRUE,
                                    verbose=TRUE) {
  stopifnot(all(names(filenames) %in% c("identspectrum", "quantspectrum",
                                        "identfragments", "quantfragments")))
  filenames <- as.list(filenames)

  assaydata <- new.env(hash=TRUE, parent=emptyenv())
  assaydata <- .spectrumXml2spectra(df=obj$IdentPeptideData,
                                    file=filenames$identspectrum,
                                    prefix="spectra.ident",
                                    assaydata=assaydata,
                                    fileId=1, verbose=verbose)
  assaydata <- .spectrumXml2spectra(df=obj$QuantPeptideData,
                                    file=filenames$quantspectrum,
                                    prefix="spectra.quant",
                                    assaydata=assaydata,
                                    fileId=2, verbose=verbose)

  assaydata <- .finalFragment2spectra(df=obj$IdentPeptideData,
                                      file=filenames$identfragments,
                                      prefix="fragments.ident",
                                      assaydata=assaydata,
                                      fileId=3,
                                      removeNeutralLoss=removeNeutralLoss,
                                      verbose=verbose)
  ## TODO: store fragmentstr somewhere
  assaydata <- .finalFragment2spectra(df=obj$QuantPeptideData,
                                      file=filenames$quantfragments,
                                      prefix="fragments.quant",
                                      assaydata=assaydata,
                                      fileId=4,
                                      removeNeutralLoss=removeNeutralLoss,
                                      verbose=verbose)
  return(assaydata)
}

#' crossmatching
#' compares ident fragments vs quant product spectrum and
#' quant fragments vs ident product spectrum
#' @param obj synapter object
#' @param assaydata env containing the spectra and fragment spectra
#' @param tolerance double, allowed deviation to consider a m/z as equal
#' @param verbose verbose output?
#' @return data.frame, extend/flatted matchedEmrts df with additional columns:
#' matchType,
#' spectra.identXfragments.ident, spectra.quantXfragments.quant,
#' spectra.identXfragments.quant, spectra.quantXfragments.ident
#' sorry for the names
crossmatching <- function(obj, assaydata, tolerance=25e-6, verbose=TRUE) {
  if (verbose) {
    message("create flat EMRTs data.frame")
  }
  emrts <- flatMatchedEMRTs(obj$MatchedEMRTs)

  prefixes <- paste(rep(c("spectra", "fragments"), each=2),
                    rep(c("ident", "quant"), times=2), sep=".")
  # "spectra.ident"   "spectra.quant"   "fragments.ident" "fragments.quant"

  keys <- paste(rep(prefixes, each=nrow(emrts)),
                rep(unlist(emrts[, c("precursor.leID.ident",
                                     "precursor.leID.quant")]), times=2),
                sep=":")
  keysm <- matrix(keys, ncol=4)

  cmb <- list(c(1, 3), c(2, 4),
              c(1, 4), c(2, 3))

  cols <- sapply(cmb, function(x)paste0(prefixes[x], collapse="X"))
  # "spectra.identXfragments.ident" ...

  if (verbose) {
    message("Look for common peaks")
    pb <- txtProgressBar(0, 4*nrow(emrts), style=3)
  }

  emrts[, cols] <- lapply(cmb, function(i) {
    apply(keysm[, i], 1, function(k) {
      if (verbose) {
        setTxtProgressBar(pb, pb$getVal()+1)
      }
      .commonPeaks(.getSpectrum(k[1], envir=assaydata),
                   .getSpectrum(k[2], envir=assaydata),
                   tolerance=tolerance)
    })
  })

  if (verbose) {
    close(pb)
  }

  return(emrts)
}

#' plot crossmatching
#' @param file name of pdf file
#' @param obj synapter object
#' @param cx crossmatching df, result of crossmatching
#' @param spectra product spectra readSpectraAndFragments(...)$spectra
#' @param fragments fragments readSpectraAndFragments(...)$fragments
#' @param fragmentsdf fragments df readSpectraAndFragments(...)$fragmentsdf
#' @param what which subset
#' @param legend.cex cex for legend text
#' @param verbose verbose output?
#' @return data.frame, extend/flatted matchedEmrts df with additional columns:
#' cxIdentSxQuantF, cxIdentFxQuantS, matchType
plotCrossmatching <- function(file, obj, cx, spectra, fragments, fragmentsdf,
                              what=c("all", "unique-true", "unique-false",
                                     "non-unique-true", "non-unique-false"),
                              legend.cex=0.75, verbose=TRUE) {
  what <- match.arg(what)

  if (what != "all") {
    cx <- cx[cx$matchType == what, ]
  }

  ident.id <- as.character(cx$precursor.leID.ident)
  quant.id <- as.character(cx$precursor.leID.quant)

  identIdx <- match(ident.id, obj$IdentPeptideData$precursor.leID)
  quantIdx <- match(quant.id, obj$QuantPeptideData$precursor.leID)

  identFragmentIdx <- lapply(ident.id, function(x) {
    which(x == fragmentsdf$ident$precursor.leID)
  })
  quantFragmentIdx <- lapply(quant.id, function(x) {
    which(x == fragmentsdf$quant$precursor.leID)
  })

  metaCols <- c("peptide.seq", "precursor.mhp", "precursor.z")
  metaColsFrx <- c("precursor.leID", metaCols)

  if (verbose) {
    message("plot ", what, " to ", file)
    pb <- txtProgressBar(0, nrow(cx), style=3)
  }

  pdf(file=file, width=12, height=7)
  oldPar <- par(no.readonly=TRUE)
  on.exit(par(oldPar))
  on.exit(dev.off(), add=TRUE)
  par(mar=rep(2, 4), mfrow=c(1, 2))

  for (i in 1:nrow(cx)) {
    identMeta <- cx[i, c("precursor.leID.ident", metaCols)]
    quantMeta <- cx[i, c("precursor.leID.ident", metaCols)]
    names(identMeta) <- c("leID", "seq", "mhp", "z")
    names(quantMeta) <- c("leID", "seq", "mhp", "z")
    .plotIdentVsQuantSpectra(ident=get(ident.id[i], envir=spectra$ident),
                             ident.metadata=identMeta,
                             quant=get(quant.id[i], envir=spectra$quant),
                             quant.metadata=quantMeta,
                             ident.norm=obj$IdentPeptideData$precursor.inten[identIdx[i]],
                             quant.norm=obj$QuantPeptideData$precursor.inten[quantIdx[i]],
                             main="spectra", legend.cex=legend.cex)

    identMeta <- fragmentsdf$ident[identFragmentIdx[[i]][1], metaColsFrx]
    quantMeta <- fragmentsdf$quant[quantFragmentIdx[[i]][1], metaColsFrx]
    names(identMeta) <- c("leID", "seq", "mhp", "z")
    names(quantMeta) <- c("leID", "seq", "mhp", "z")

    identFragmentStr <- fragmentsdf$ident$fragment.str[identFragmentIdx[[i]]]
    quantFragmentStr <- fragmentsdf$quant$fragment.str[quantFragmentIdx[[i]]]
    identFragmentStr <-
      identFragmentStr[order(fragmentsdf$ident$fragment.mhp[identFragmentIdx[[i]]])]
    quantFragmentStr <-
      quantFragmentStr[order(fragmentsdf$quant$fragment.mhp[quantFragmentIdx[[i]]])]

    .plotIdentVsQuantSpectra(ident=get(ident.id[i], envir=fragments$ident),
                             ident.metadata=identMeta,
                             quant=get(quant.id[i], envir=fragments$quant),
                             quant.metadata=quantMeta,
                             ident.norm=obj$IdentPeptideData$precursor.inten[identIdx[i]],
                             quant.norm=obj$QuantPeptideData$precursor.inten[quantIdx[i]],
                             ident.fragment.str=identFragmentStr,
                             quant.fragment.str=quantFragmentStr,
                             main="fragments", legend.cex=legend.cex)
    if (verbose) {
      setTxtProgressBar(pb, i)
    }
  }

  if (verbose) {
    close(pb)
  }
}

