#' parse synapter Spectrum.xml files
#'
#' Stupid parser for one of the ugliest pseudo-xml formats I have ever seen.
#'
#' @param file file path
#' @param ms1 should we read ms1 spectra?
#' @param encoding file encoding, seems to be windows specific
#' @param verbose verbose output?
#'
#' @return a list of length == 3; names: ms1, m2, assignments
#'  ms1: matrix of ms1 spectra information
#'  ms2: matrix of ms2 spectra information
#'  assignments: environment (key == leID), values == he_id
#'
.readSynapterSpectrumXml <- function(file, ms1=FALSE,
                                     encoding="Windows-1252",
                                     verbose=TRUE) {
  stopifnot(file.exists(file))

  ## helper functions
  .extractName <- function(x) {
    gsub("^.*NAME=\\\"([[:alpha:]_]+)\\\".*$", "\\1", x)
  }
  .extractLEID <- function(x) {
    gsub("^.*LE_ID=\\\"([[:digit:]]+)\\\".*$", "\\1", x)
  }
  .extractHEID <- function(x) {
    gsub("^.*HE_ID=\\\"([[:digit:],]+)\\\".*$", "\\1", x)
  }

  .createMsMatrix <- function(x, header) {
    ms <- do.call(rbind, strsplit(x, "[[:space:]]+"))
    ms <- ms[, -1]
    mode(ms) <- "double"
    colnames(ms) <- header
    return(ms)
  }

  if (verbose) {
    message("Reading ", file)
  }
  content <- readLines(file, encoding=encoding, warn=FALSE)

  if (verbose) {
    message("Search line numbers for Header information")
  }
  linesField <- grep("<FIELD", content, fixed=TRUE)
  splitPoint <- which(diff(linesField) > 1)
  linesFieldMs1 <- linesField[1:splitPoint]
  linesFieldMs2 <- linesField[(splitPoint+1):length(linesField)]

  if (verbose) {
    message("Read Header information")
  }

  header1 <- .extractName(content[linesFieldMs1])
  header2 <- .extractName(content[linesFieldMs2])

  if (ms1) {
    if (verbose) {
      message("Search line numbers for MS1 Data")
    }
    linesMs1 <- c(grep("<DATA", content, fixed=TRUE)+1,
                  grep("</DATA", content, fixed=TRUE)-1)
  }

  if (verbose) {
    message("Search line numbers for MS2 Data")
  }
  linesMs2 <- c(grep("<HE_DATA", content, fixed=TRUE)+1,
                grep("</HE_DATA", content, fixed=TRUE)-1)

  if (ms1) {
    if (verbose) {
      message("Read MS1 Data (", paste(linesMs1, collapse=":"), ")")
    }
    range <- seq(linesMs1[1], linesMs1[2])
    ms1 <- .createMsMatrix(content[range], header1)
  } else {
    ms1 <- matrix()
  }

  if (verbose) {
    message("Read MS2 Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesMs2[1], linesMs2[2])
  ms2 <- .createMsMatrix(content[range], header2)

  if (verbose) {
    message("Search line numbers for MS1 to MS2 assignment")
  }
  linesAssignment <- c(grep("<PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)+1,
                       grep("</PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)-1)

  if (verbose) {
    message("Read Assignment Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesAssignment[1], linesAssignment[2])

  le_ids <- .extractLEID(content[range])
  he_ids <- lapply(MSnbase:::utils.ssv2list(
                     .extractHEID(content[range]), sep=","), as.numeric)

  assignments <- new.env(hash=TRUE, parent=emptyenv(), size=length(le_ids))
  for (i in seq(along=le_ids)) {
    assign(le_ids[i], he_ids[[i]], envir=assignments)
  }

  return(list(ms1=ms1, ms2=ms2, assignments=assignments))
}

#' read spectrum.xml and turn data into MSnbase::Spectrum2 objects
#' @param df corresponding df from the synapter object ({Ident,Quant}PeptideData)
#' @param file filename
#' @param prefix character, prefix for the keyvalue in assaydata
#' (e.g.,"ident.spectra")
#' @param assaydata environment
#' @param fileId integer, optional
#' @param verbose verbose output
#' @return modified assaydata
.spectrumXml2spectra <- function(df, file, prefix, assaydata, fileId=0,
                                 verbose=TRUE) {
  stopifnot(!missing(prefix))

  xml <- .readSynapterSpectrumXml(file, ms1=FALSE, verbose=verbose)

  peptideinfo <- df[!duplicated(df$precursor.leID), ]
  keys <- paste(prefix, df$precursor.leID, sep=":")
  sequence_keys <- paste("peptide.seq", prefix, df$precursor.leID, sep=":")

  if (verbose) {
    message("Convert spectra data.frames to MSnbase::Spectrum2 objects")
    pb <- txtProgressBar(0, nrow(peptideinfo), style=3)
  }

  for (i in 1:nrow(peptideinfo)) {
    assign(keys[i],
           .createMs2SpectrumFromSpectrumXml(peptideinfo[i, ], xml$ms2,
                                             xml$assignments, fileId=fileId),
           envir=assaydata)
    assign(sequence_keys[i], peptideinfo$peptide.seq[i], envir=assaydata)

    if (verbose) {
      setTxtProgressBar(pb, i)
    }
  }
  if (verbose) {
    close(pb)
  }
  return(assaydata)
}

#' create MS2 spectrum from spectrum.xml data
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData
#' @param ms2 ms2 matrix generated by .readSynapterSpectrumXml
#' @param assignments env generated by .readSynapterSpectrumXml
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMs2SpectrumFromSpectrumXml <- function(peptideinfo, ms2, assignments,
                                              fileId=0) {
  key <- as.character(peptideinfo$precursor.leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(.createMsnbaseSpectrum2(peptideinfo=peptideinfo,
                                   mass=ms2[i, "Mass"],
                                   intensity=ms2[i, "Intensity"],
                                   fileId=fileId))
  } else {
    return(.createEmptyMsnbaseSpectrum2())
  }
}

#' create MS2 spectrum from final_fragment.csv data
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData
#' @param fragments data.frame generated by readFragments
#' @param assignments env
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMs2SpectrumFromFragments <- function(peptideinfo, fragments, assignments,
                                            fileId=0) {
  key <- as.character(peptideinfo$precursor.leID)

  if (exists(key, envir=assignments)) {
    i <- get(key, envir=assignments)

    return(.createMsnbaseSpectrum2(peptideinfo=peptideinfo,
                                   mass=fragments$product.mhp[i],
                                   intensity=fragments$product.inten[i],
                                   fileId=fileId))
  } else {
    return(.createEmptyMsnbaseSpectrum2())
  }
}

#' create an instance of an MSnbase::Spectrum2 object
#' @param peptideinfo row from synapterobj${Ident,Quant}PeptideData or
#' final_fragment.csv
#' @param mass mass/mz
#' @param intensity intensity
#' @param fileId integer, optional
#' @return Spectrum2 object
.createMsnbaseSpectrum2 <- function(peptideinfo, mass, intensity, fileId=0) {
  ## just to be sure, you can't trust any information in the csv/xml files
  o <- order(mass)
  new("Spectrum2",
      precScanNum=as.integer(peptideinfo$precursor.leID),
      precursorMz=peptideinfo$precursor.mhp,
      precursorIntensity=peptideinfo$precursor.inten,
      precursorCharge=peptideinfo$precursor.z,
      rt=peptideinfo$precursor.retT,
      centroided=TRUE,
      # tic=precursor.inten,
      peaksCount=length(mass),
      acquisitionNum=as.integer(peptideinfo$precursor.leID),
      mz=mass[o], intensity=intensity[o],
      fromFile=as.integer(fileId))
}

#' create an empty instance of an MSnbase::Spectrum2 object
#' @return Spectrum2 object
.createEmptyMsnbaseSpectrum2 <- function() {
  new("Spectrum2")
}

#' common peaks
#' @param x spectrum1 (MSnbase::Spectrum2)
#' @param y spectrum2 (MSnbase::Spectrum2)
#' @param tolerance double, allowed deviation
#' @return logical, common peaks in y
.commonPeaks <- function(x, y, tolerance=25e-6) {
  mx <- mz(x)
  my <- mz(y)

  if (length(mx) == 0 || length(my) == 0) {
    return(logical(length(my)))
  } else if (length(mx) == 1) {
    return(abs(mx-my)/my < tolerance)
  }

  ## adopted from MALDIquant:::.which.closest
  ## find left interval
  lIdx <- findInterval(my, mx, rightmost.closed=FALSE, all.inside=TRUE)
  ## find right interval
  rIdx <- lIdx+1L

  ## calculate relative differences for left and right nearest point
  lDiff <- abs(mx[lIdx]-my)/mx[lIdx]
  rDiff <- abs(mx[rIdx]-my)/mx[rIdx]

  return(pmin(lDiff, rDiff) < tolerance)
}

#' number of common peaks
#' @param x spectrum1 (MSnbase::Spectrum2)
#' @param y spectrum2 (MSnbase::Spectrum2)
#' @param tolerance double, allowed deviation
#' @return double, number of common peaks
.nCommonPeaks <- function(x, y, tolerance=25e-6) {
  return(sum(.commonPeaks(x, y, tolerance=tolerance)))
}

#' @param spectra list, 4 MSnbase::Spectrum2 objects
#' @param norm normalise spectra?
#' @param fragments list, 2 character vectors containing the fragment.str
#' @param tolerance double, allowed deviation
#' @param ... passed to .plotIdentVsQuantSpectra
.plotSpectraVsFragments <- function(spectra, norm=TRUE, fragments,
                                    tolerance=25e-6, ...) {
  if (norm) {
    spectra <- lapply(spectra, normalize, method="precursor")
  }

  mass <- unlist(lapply(spectra, mz))
  xlim <- c(min(mass), max(mass))

  inten <- unlist(lapply(spectra, intensity))
  maxInten <- max(inten)
  ylim <- c(-maxInten, maxInten)

  oldPar <- par(no.readonly=TRUE)
  on.exit(par(oldPar))
  par(mfrow=c(1, 2))

  par(mar=c(2, 2, 2, 0.5)) #c(bottom, left, top, right)
  .plotIdentVsQuantSpectra(spectra[1:2], main="spectra",
                           common=list(.commonPeaks(spectra[[4]],
                                                    spectra[[1]],
                                                    tolerance),
                                       .commonPeaks(spectra[[3]],
                                                    spectra[[2]],
                                                    tolerance)),
                           xlim=xlim, ylim=ylim, ...)
  par(mar=c(2, 0.5, 2, 2)) #c(bottom, left, top, right)
  .plotIdentVsQuantSpectra(spectra[3:4], main="fragments", fragments=fragments,
                           common=list(.commonPeaks(spectra[[4]],
                                                    spectra[[3]],
                                                    tolerance),
                                       .commonPeaks(spectra[[3]],
                                                    spectra[[4]],
                                                    tolerance)),
                           xlim=xlim, ylim=ylim, yaxt="n", ...)
  axis(4)
}

#' plot ident vs quant spectra
#' @param spectra list, 2 MSnbase::Spectrum2 objects
#' @param sequences list, 2 character vectors containing the peptide.seq
#' @param fragments list, 2 character vectors containing the fragment.str
#' @param common list, 2 logical vectors
#' @param xlab label for x-axis
#' @param ylab label for y-axis
#' @param xlim limits for x-axis
#' @param ylim limits for y-axis
#' @param fragments.cex cex for fragments
#' @param legend.cex cex for legend
.plotIdentVsQuantSpectra <- function(spectra,
                                     sequences,
                                     fragments=list(character(), character()),
                                     common,
                                     main=character(),
                                     xlab="mhp", ylab="intensity",
                                     xlim, ylim,
                                     fragments.cex=0.5,
                                     legend.cex=0.5, ...) {
  if (missing(xlim)) {
    mass <- unlist(lapply(spectra, mz))
    xlim <- c(min(c(mass, 0)), max(c(mass, 0)))
  }

  if (missing(ylim)) {
    inten <- unlist(lapply(spectra, intensity))
    maxInten <- max(c(inten, 0))
    ylim <- c(-maxInten, maxInten)
  }

  if (missing(common)) {
    common <- lapply(spectra, function(x)logical(peaksCount(x)))
  }

  plot(NA, type="h", col=1,
       main=main,
       xlab=xlab, ylab=ylab,
       xlim=xlim, ylim=ylim,
       ...)
  abline(h=0, col="#808080")

  orientation <- c(1, -1)
  text.pos <- c(3, 1)
  legend.pos <- c("topleft", "bottomleft")
  legend.prefix <- c("ident", "quant")
  pal <- brewer.pal(11, "RdYlBu")
  cols <- c(pal[c(9, 11)], pal[c(3, 1)])
  pch <- c(NA, 19)

  for (i in seq(along=spectra)) {
    lines(mz(spectra[[i]]), orientation[i]*intensity(spectra[[i]]),
          type="h", col=cols[(i-1)*2+common[[i]]+1L], lwd=1.5)
    points(mz(spectra[[i]]), orientation[i]*intensity(spectra[[i]]),
           col=cols[(i-1)*2+common[[i]]+1L], pch=pch[common[[i]]+1L],
           cex=0.5)

    if (length(fragments[[i]])) {
      text(mz(spectra[[i]]), orientation[i]*intensity(spectra[[i]]),
           fragments[[i]], pos=text.pos[i], offset=0.25,
           cex=fragments.cex, col="#808080")
    }

    label <- paste0(legend.prefix[i], ".leID: ", precScanNum(spectra[[i]]))

    if (peaksCount(spectra[[i]])) {
      label <- paste0(label, ", mhp: ", precursorMz(spectra[[i]]),
                             ", z: ", precursorCharge(spectra[[i]]),
                             ", seq: ", sequences[[i]],
                             ", cx: ", sum(common[[i]]))
    }

    legend(legend.pos[i], legend=label, bty="n", cex=legend.cex)
  }
}

#' readSpectraAndFragments
#' @param obj synapter object
#' @param filenames named list of filenames list(identspectrum, quantspectrum,
#' @param removeNeutralLoss remove rows with neutral loss != "none"?
#' @param verbose verbose output?
#' @return  env with MSnbase::Spectrum2 objects
readSpectraAndFragments <- function(obj, filenames, removeNeutralLoss=TRUE,
                                    verbose=TRUE) {
  stopifnot(all(names(filenames) %in% c("identspectrum", "quantspectrum",
                                        "identfragments", "quantfragments")))
  filenames <- as.list(filenames)

  assaydata <- new.env(hash=TRUE, parent=emptyenv())
  assaydata <- .spectrumXml2spectra(df=obj$IdentPeptideData,
                                    file=filenames$identspectrum,
                                    prefix="spectra.ident",
                                    assaydata=assaydata,
                                    fileId=1, verbose=verbose)
  assaydata <- .spectrumXml2spectra(df=obj$QuantPeptideData,
                                    file=filenames$quantspectrum,
                                    prefix="spectra.quant",
                                    assaydata=assaydata,
                                    fileId=2, verbose=verbose)

  assaydata <- .finalFragment2spectra(df=obj$IdentPeptideData,
                                      file=filenames$identfragments,
                                      prefix="fragments.ident",
                                      assaydata=assaydata,
                                      fileId=3,
                                      removeNeutralLoss=removeNeutralLoss,
                                      verbose=verbose)
  assaydata <- .finalFragment2spectra(df=obj$QuantPeptideData,
                                      file=filenames$quantfragments,
                                      prefix="fragments.quant",
                                      assaydata=assaydata,
                                      fileId=4,
                                      removeNeutralLoss=removeNeutralLoss,
                                      verbose=verbose)
  return(assaydata)
}

#' crossmatching
#' compares ident fragments vs quant product spectrum and
#' quant fragments vs ident product spectrum
#' @param obj synapter object
#' @param assaydata env containing the spectra and fragment spectra
#' @param tolerance double, allowed deviation to consider a m/z as equal
#' @param verbose verbose output?
#' @return data.frame, extend/flatted matchedEmrts df with additional columns:
#' matchType,
#' spectra.identXfragments.ident, spectra.quantXfragments.quant,
#' spectra.identXfragments.quant, spectra.quantXfragments.ident
#' sorry for the names
crossmatching <- function(obj, assaydata, tolerance=25e-6, verbose=TRUE) {
  if (verbose) {
    message("create flat EMRTs data.frame")
  }
  emrts <- flatMatchedEMRTs(obj$MatchedEMRTs)

  prefixes <- paste(rep(c("spectra", "fragments"), each=2),
                    rep(c("ident", "quant"), times=2), sep=".")
  # "spectra.ident"   "spectra.quant"   "fragments.ident" "fragments.quant"

  keys <- paste(rep(prefixes, each=nrow(emrts)),
                rep(unlist(emrts[, c("precursor.leID.ident",
                                     "precursor.leID.quant")]), times=2),
                sep=":")
  keysm <- matrix(keys, ncol=4)

  cmb <- list(c(1, 3), c(2, 4),
              c(1, 4), c(2, 3))

  cols <- sapply(cmb, function(x)paste0(prefixes[x], collapse="X"))
  # "spectra.identXfragments.ident" ...

  if (verbose) {
    message("Look for common peaks")
    pb <- txtProgressBar(0, 4*nrow(emrts), style=3)
  }

  emrts[, cols] <- lapply(cmb, function(i) {
    apply(keysm[, i], 1, function(k) {
      if (verbose) {
        setTxtProgressBar(pb, pb$getVal()+1)
      }
      .nCommonPeaks(.getSpectrum(k[1], envir=assaydata),
                    .getSpectrum(k[2], envir=assaydata),
                    tolerance=tolerance)
    })
  })

  if (verbose) {
    close(pb)
  }

  return(emrts)
}

#' plot crossmatching
#' @param cx crossmatching df, result of crossmatching
#' @param assaydata env, spectra
#' @param legend.cex cex for legend text
#' @param tolerance double, allowed deviation
#' @param verbose verbose output?
#' @return data.frame, extend/flatted matchedEmrts df with additional columns:
#' cxIdentSxQuantF, cxIdentFxQuantS, matchType
plotCrossmatching <- function(cx, assaydata,
                              legend.cex=0.75, tolerance=25e-6,
                              verbose=TRUE) {
  prefixes <- paste(rep(c("spectra", "fragments"), each=2),
                    rep(c("ident", "quant"), times=2), sep=".")
  keys <- paste(rep(prefixes, each=nrow(cx)),
                rep(unlist(cx[, c("precursor.leID.ident",
                                  "matched.quant.spectrumIDs")]), times=2),
                sep=":")
  keysm <- matrix(keys, ncol=4)

  if (verbose) {
    pb <- txtProgressBar(0, nrow(cx), style=3)
  }
  for (i in 1:nrow(cx)) {
    .plotSpectraVsFragments(spectra=.getSpectra(keysm[i, ], envir=assaydata),
                            sequences=.getSequences(keysm[i, ],
                                                    envir=assaydata),
                            fragments=.getFragments(keysm[i, 3:4],
                                                    envir=assaydata),
                            tolerance=tolerance, legend.cex=legend.cex)
    if (verbose) {
      setTxtProgressBar(pb, i)
    }
  }

  if (verbose) {
    close(pb)
  }
}

