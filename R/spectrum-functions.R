#' parse synapter Spectrum.xml files
#'
#' Stupid parser for one of the ugliest pseudo-xml formats I have ever seen.
#'
#' @param file file path
#' @param ms1 should we read ms1 spectra?
#' @param encoding file encoding, seems to be windows specific
#' @param verbose verbose output?
#'
#' @return a list of length == 3; names: ms1, m2, assignments
#'  ms1: matrix of ms1 spectra information
#'  ms2: matrix of ms2 spectra information
#'  assignments: data.frame that holds the connection between ms1 and ms2
#'
.readSynapterSpectrumXml <- function(file, ms1=FALSE,
                                     encoding="Windows-1252",
                                     verbose=TRUE) {
  stopifnot(file.exists(file))

  ## helper functions
  .extractName <- function(x) {
    gsub("^.*NAME=\\\"([[:alpha:]_]+)\\\".*$", "\\1", x)
  }
  .extractLEID <- function(x) {
    gsub("^.*LE_ID=\\\"([[:digit:]]+)\\\".*$", "\\1", x)
  }
  .extractHEID <- function(x) {
    gsub("^.*HE_ID=\\\"([[:digit:],]+)\\\".*$", "\\1", x)
  }

  .createMsMatrix <- function(x, header) {
    ms <- do.call(rbind, strsplit(x, "[[:space:]]+"))
    ms <- ms[, -1]
    mode(ms) <- "double"
    colnames(ms) <- header
    return(ms)
  }

  if (verbose) {
    message("Reading ", file)
  }
  content <- readLines(file, encoding=encoding, warn=FALSE)

  if (verbose) {
    message("Search line numbers for Header information")
  }
  linesField <- grep("<FIELD", content, fixed=TRUE)
  splitPoint <- which(diff(linesField) > 1)
  linesFieldMs1 <- linesField[1:splitPoint]
  linesFieldMs2 <- linesField[(splitPoint+1):length(linesField)]

  if (verbose) {
    message("Read Header information")
  }

  header1 <- .extractName(content[linesFieldMs1])
  header2 <- .extractName(content[linesFieldMs2])

  if (ms1) {
    if (verbose) {
      message("Search line numbers for MS1 Data")
    }
    linesMs1 <- c(grep("<DATA", content, fixed=TRUE)+1,
                  grep("</DATA", content, fixed=TRUE)-1)
  }

  if (verbose) {
    message("Search line numbers for MS2 Data")
  }
  linesMs2 <- c(grep("<HE_DATA", content, fixed=TRUE)+1,
                grep("</HE_DATA", content, fixed=TRUE)-1)


  if (ms1) {
    if (verbose) {
      message("Read MS1 Data (", paste(linesMs1, collapse=":"), ")")
    }
    range <- seq(linesMs1[1], linesMs1[2])
    ms1 <- .createMsMatrix(content[range], header1)
  } else {
    ms1 <- matrix()
  }

  if (verbose) {
    message("Read MS2 Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesMs2[1], linesMs2[2])
  ms2 <- .createMsMatrix(content[range], header2)

  if (verbose) {
    message("Search line numbers for MS1 to MS2 assignment")
  }
  linesAssignment <- c(grep("<PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)+1,
                       grep("</PRECURSOR_PRODUCT_BIN", content, fixed=TRUE)-1)

  if (verbose) {
    message("Read Assignment Data (", paste(linesMs2, collapse=":"), ")")
  }
  range <- seq(linesAssignment[1], linesAssignment[2])

  assignments <- data.frame(le_id=.extractLEID(content[range]),
                            he_id=.extractHEID(content[range]),
                            stringsAsFactors=FALSE)

  return(list(ms1=ms1, ms2=ms2, assignments=assignments))
}

#' create MS2 spectrum from spectrum.xml data
#' @param precursor.leID low energy ID
#' @param ms2 ms2 matrix generated by .readSynapterSpectrumXml
#' @param assignments df generated by .readSynapterSpectrumXml
#' @return a 2-column matrix with columns mass, intensity
.createMs2SpectrumFromSpectrumXml <- function(precursor.leID,
                                              ms2, assignments) {
  i <- which(precursor.leID == assignments$le_id)

  if (!length(i)) {
    return(cbind(mass=0, intensity=0))
  }

  ids <- as.numeric(unlist(strsplit(assignments$he_id[i], ",")))
  mass <- ms2[ids, "Mass"]
  intensity <- ms2[ids, "Intensity"]

  return(.createSpectrum(mass, intensity))
}

#' create MS2 spectrum from final_fragment.csv data
#' @param precursor.leID low energy ID
#' @param df data.frame generated by readFragments
#' @return a 2-column matrix with columns mass, intensity
.createMs2SpectrumFromFragments <- function(precursor.leID, df) {
  i <- which(df$precursor.leID == precursor.leID)

  if (!length(i)) {
    return(cbind(mass=0, intensity=0))
  }

  mass <- df$product.mhp[i]
  intensity <- df$product.inten[i]

  return(.createSpectrum(mass, intensity))
}

#' create a spectrum matrix (it orders the spectrum by mass and removes NAs)
#' @param mass mass or m/z
#' @param intensity intensity values
#' @return a 2-column matrix with columns mass, intensity
.createSpectrum <- function(mass, intensity) {

  notNA <- which(!is.na(mass) & !is.na(intensity))

  mass <- mass[notNA]
  intensity <- intensity[notNA]

  o <- order(mass)

  return(cbind(mass=mass[o], intensity=intensity[o]))
}

#' common peaks
#' @param x matrix, spectrum 1
#' @param y matrix, spectrum 2
#' @param tolerance double, allowed deviation
#' @return double, number of common peaks
.commonPeaks <- function(x, y, tolerance=25e-6) {
  mx <- x[, 1]
  my <- y[, 1]

  if (length(mx) <= 1) {
    return(sum( abs(mx-my)/my < tolerance))
  }

  ## adopted from MALDIquant:::.which.closest

  ## find left interval
  lIdx <- findInterval(my, mx, rightmost.closed=FALSE, all.inside=TRUE)
  ## find right interval
  rIdx <- lIdx+1L

  ## calculate relative differences for left and right nearest point
  lDiff <- abs(mx[lIdx]-my)/mx[lIdx]
  rDiff <- abs(mx[rIdx]-my)/mx[rIdx]

  return(sum(pmin(lDiff, rDiff) < tolerance))
}

#' plot identification vs quantitation spectra/fragments
#' @param ident matrix, spectrum 1
#' @param ident.metadata named character vector (is plotted as legend)
#' @param quant matrix, spectrum 2
#' @param quant.named character vector (is plotted as legend)
#' @param main title
#' @param xlab label for x-axis
#' @param ylab label for y-axis
#' @param legend.cex cex for legend text
#' @return double, number of common peaks
.plotIdentVsQuantSpectra <- function(ident, ident.metadata,
                                     quant, quant.metadata,
                                     main="", xlab="mhp", ylab="intensity",
                                     legend.cex=1) {

    xlim <- c(min(ident[, 1], quant[, 1]), max(ident[, 1], quant[, 1]))
    ylim <- c(-max(ident[, 2], quant[, 2]), max(ident[, 2], quant[, 2]))

    plot(ident[,1], ident[,2], type="h", col=1,
         main=main, xlab=xlab, ylab=ylab,
         xlim=xlim, ylim=ylim)
    lines(quant[,1], -quant[,2], type="h", col=2)
    abline(h=0, col="#808080")

    ident.legend <- paste(names(ident.metadata), ident.metadata, sep=": ",
                          collapse=", ")
    quant.legend <- paste(names(quant.metadata), quant.metadata, sep=": ",
                          collapse=", ")
    legend("topleft",
           legend=paste("ident:", ident.legend), bty="n", cex=legend.cex)
    legend("bottomleft",
           legend=paste("quant:", quant.legend), bty="n", cex=legend.cex)
}

#' readSpectraAndFragments
#' @param filenames named list of filenames list(identspectrum, quantspectrum,
#' @param removeNeutralLoss remove rows with neutral loss != "none"?
#' @param verbose verbose output?
readSpectraAndFragments <- function(filenames, removeNeutralLoss=TRUE,
                                    verbose=TRUE) {
  stopifnot(all(names(filenames) %in% c("identspectrum", "quantspectrum",
                                        "identfragments", "quantfragments")))
  spectra <- list()
  spectra$ident <- .readSynapterSpectrumXml(filenames$identspectrum,
                                            verbose=verbose)
  spectra$quant <- .readSynapterSpectrumXml(filenames$quantspectrum,
                                            verbose=verbose)

  fragments <- list()
  fragments$ident <- .readFragements(filenames$identfragments,
                                     removeNeutralLoss=removeNeutralLoss)
  fragments$quant <- .readFragements(filenames$quantfragments,
                                     removeNeutralLoss=removeNeutralLoss)
  return(list(spectra, fragments))
}

#' crossmatching
#' compares ident fragments vs quant product spectrum and
#' quant fragments vs ident product spectrum
