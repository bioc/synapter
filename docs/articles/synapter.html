<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Combining HDMSe/MSe data using <em>synapter</em> to optimise identification and quantitation • synapter</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">synapter</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Combining HDMSe/MSe data using <em>synapter</em> to optimise identification and quantitation</h1>
                        <h4 class="author">Laurent Gatto</h4>
            <address class="author_afil">
      Computational Proteomics Unit, Cambridge, UK.<br><h4 class="author">Sebastian Gibb</h4>
            <address class="author_afil">
      Department of Anesthesiology and Intensive Care, University Medicine Greifswald, Germany.<br><h4 class="author">Pavel V. Shliaha</h4>
            <address class="author_afil">
      Department of Biochemistry and Molecular Biology, University of Southern Denmark, Denmark.<br>
</address>
</address>
</address>
</div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>This vignette describes the functionality implemented in the ‘synapter’ package. It allows to re-analyse label-free quantitative proteomics data obtained on a Synapt G2 instrument to optimise quantitation and identification. Several combination strategies are possible and described. Typically, a user can combine identification-optimised data (HDMS<span class="math inline">\(^E\)</span> data using ion mobility separation) and quantitation-optimised data (MS<span class="math inline">\(^E\)</span> data). Additionally, a method to combine several data files into a <em>master</em> set while controlling the false discovery rate, is presented.</p>
    </div>
    
<div class="contents">
<div id="foreword" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#foreword" class="anchor"></a>Foreword</h1>
<p><a href="http://bioconductor.org/packages/synapter"><em>synapter</em></a> is free and open-source software. If you use it, please support the project by citing it in publications:</p>
<blockquote>
<p>Nicholas James Bond, Pavel Vyacheslavovich Shliaha, Kathryn S. Lilley, and Laurent Gatto. <em>Improving qualitative and quantitative performance for MS<span class="math inline">\(^E\)</span>-based label free proteomics.</em> J. Proteome Res., 2013, 12 (6), pp 2340–2353</p>
</blockquote>
</div>
<div id="questions-and-bugs" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#questions-and-bugs" class="anchor"></a>Questions and bugs</h1>
<p>For bugs, typos, suggestions or other questions, please file an issue in our tracking system (<a href="https://github.com/lgatto/synapter/issues" class="uri">https://github.com/lgatto/synapter/issues</a>) providing as much information as possible, a reproducible example and the output of <code>sessionInfo()</code>.</p>
<p>If you don’t have a GitHub account or wish to reach a broader audience for general questions about proteomics analysis using R, you may want to use the Bioconductor support site: <a href="https://support.bioconductor.org/" class="uri">https://support.bioconductor.org/</a>.</p>
</div>
<div id="sec:intro" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:intro" class="anchor"></a>Introduction</h1>
<div id="sec:bkg" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:bkg" class="anchor"></a>Background</h2>
<p>The main functionality of <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> is to combine proteomics data acquired under different mass spectrometry settings or with different samples to (i) optimise the respective qualities of the two data sets or (ii) increase the number of identifications, thereby decreasing missing values. Besides <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> offers other functionality inaccessible in the default pipeline, like peptide FDR estimation and filtering on peptide match type and peptide uniqueness.</p>
<p>The example that motivated the development of this package was to combine data obtained on a Synapt G2 instrument:</p>
<ol style="list-style-type: decimal">
<li>HDMS<span class="math inline">\(^E\)</span> data, acquired with additional peptide separation using an ion mobility cell, thus leading to better (both in number and in quality) identification and</li>
<li>standard MS<span class="math inline">\(^E\)</span> data (acquired without ion mobility separation), providing better data quantitation.</li>
</ol>
<p>The former is data is called <em>identification peptides</em> and the latter <em>quantitation peptides</em>, irrespective of the acquisition mode (HDMS<span class="math inline">\(^E\)</span> or MS<span class="math inline">\(^E\)</span>). This HDMS<span class="math inline">\(^E\)</span>/MS<span class="math inline">\(^E\)</span> design is used in this document to illustrate the <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> package.</p>
<p>However, although HDMS<span class="math inline">\(^E\)</span> mode possesses superior identification and MS<span class="math inline">\(^E\)</span> mode superior quantitation capabilities and transferring identifications from HDMS<span class="math inline">\(^E\)</span> to MS<span class="math inline">\(^E\)</span> is a priori the most efficient setup, identifications can be transferred between any runs, independently of the acquisition mode. This allows to reduce the number of missing values, one of the primary limitation of label-free proteomics. Thus users will benefit from <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>’s functionality even if they run their instruments in a single mode (HDMS<span class="math inline">\(^E\)</span> or MS<span class="math inline">\(^E\)</span> only).</p>
<p>However, as will be shown in section <a href="#sec:analysis">Data analysis</a>, transferring identifications from multiple runs to each other increases analysis time and peptide FDR within the analysis. <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> allows to minimise these effects to acceptable degree by choosing runs to transfer identifications from and merging them in the <em>master</em> HDMS<span class="math inline">\(^E\)</span> file.</p>
<p>This data processing methodology is described in section <a href="#sec:synapter">HDMS<span class="math inline">\(^E\)</span>/MS<span class="math inline">\(^E\)</span> data analysis</a> and the analysis pipeline is described in section <a href="#sec:pipelines">Different pipelines</a>.</p>
<p>To maximise the benefit of combining better identification and quantitation data, it is also possible to combine several, previously merged identification data files into one <em>master</em> set. This functionality is described in section <a href="#sec:master">Using <em>master</em> peptide files</a>.</p>
<p>Finally, section <a href="#sec:msnbase">Analysis of complex experiments</a> illustrates a complete pipeline including <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> and <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> <span class="citation">(Gatto and Lilley 2012)</span> packages to perform protein label-free quantitation: how to combine multiple <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> results to represent the complete experimental design under study and further explore the data, normalise it and perform robust statistical data analysis inside the R environment.</p>
<p>The rationale underlying <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>’s functionality are described in <span class="citation">(Shliaha et al. 2013)</span> and <span class="citation">(Bond et al. 2013)</span>. The first reference describes the benefits of ion mobility separation on identification and the effects on quantitation, that led to the development of <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>, which in described and demonstrated in <span class="citation">(Bond et al. 2013)</span>.</p>
<p><em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> is written for R~<span class="citation">(R Core Team 2012)</span>, an open source, cross platform, freely available statistical computing environment and programming language<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Functionality available in the R environment can be extended though the usage of packages. Thousands of developers have contributed packages that are distributed via the Comprehensive R Archive Network (CRAN) or through specific initiatives like the Bioconductor<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> project <span class="citation">(Gentleman et al. 2004)</span>, focusing on the analysis and comprehension of high-throughput biological data.</p>
<p><em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> is such an R package dedicated to the analysis of label-free proteomics data. To obtain detailed information about any function in the package, it is possible to access it’s documentation by preceding it’s name with a question mark at the command line prompt. For example, to obtain information about the <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> package, one would type <code><a href="../reference/synapter-package.html">?synapter</a></code>.</p>
</div>
<div id="sec:install" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:install" class="anchor"></a>Installation</h2>
<p><em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> is available through the Bioconductor project. Details about the package and the installation procedure can be found on its page<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Briefly, installation of the package and all its dependencies should be done using the dedicated Bioconductor infrastructure as shown below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">source</span>(<span class="st">"https://bioconductor.org/biocLite.R"</span>)
## or, if you have already used the above before
<span class="kw">library</span>(<span class="st">"BiocInstaller"</span>)
## and to install the package
<span class="kw">biocLite</span>(<span class="st">"synapter"</span>)</code></pre></div>
<p>After installation, <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> will have to be explicitly loaded with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"synapter"</span>)</code></pre></div>
<p>so that all the package’s functionality is available to the user.</p>
</div>
</div>
<div id="sec:analysis" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:analysis" class="anchor"></a>Data analysis using <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>
</h1>
<div id="sec:input" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:input" class="anchor"></a>Preparing the input data</h2>
<p>Preparation of the data for <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> requires the <code>.raw</code> data first to be processed with Waters’ ProteinLynx Global Serve (PLGS) software. The <em>PLGS</em> result is then exported as <code>csv</code> spreadsheet files in user specified folders. These <code>csv</code> files can then be used as input for <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>.</p>
<p>We also highly recommend users to acquaint themselves with the PLGS search algorithm for data independent acquisitions <span class="citation">(G. Z. Li et al. 2009)</span>.</p>
<p>First the user has to specify the output folders for files to be used in synapter analysis as demonstrated in the figures. After the folders are specified ignore the message that appears requiring restarting PLGS.</p>
<p><img src="Figures/PLGS_output_files1.jpg" alt="Specifying PLGS output folders 1. Select Options &gt; Automation Setup." id="fig:plgs1"><img src="Figures/PLGS_output_files2.jpg" alt="Specifying PLGS output folders 2. Select path/folder." id="fig:plgs2"><img src="Figures/PLGS_output_files3.jpg" alt="Specifying PLGS output folders 3. The restart message can be ignored." id="fig:plgs3"></p>
<p>At the first stage <em>PLGS</em> performs noise reduction and centroiding, based on user specified preferences called <em>processing parameters</em>. These preferences determine thresholds in intensity for discriminating between noise peaks and peptide and fragment ion peaks in high and low energy functions of an acquisition. The optimal value of these parameters is sample dependant and different between MS<span class="math inline">\(^E\)</span> and HDMS<span class="math inline">\(^E\)</span> modes. For <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> to function properly all acquisitions in the analysis have to be processed with the same thresholds, optimal for the mode identifications are transferred from (typically HDMS<span class="math inline">\(^E\)</span> mode). The user is expected to identify optimal parameters himself for every new sample type by repeatedly analysing a representative acquisition with different thresholds.</p>
<p>After the ions peaks have been determined and centroided, the ions representing charge states and isotopes of a peptide are collapsed into a single entity called EMRT (exact mass retention time pair). The EMRTs in low energy function represent unidentified peptides and are assigned peptides sequences during database search. The total list of EMRTs can be found in the <code>pep3DAMRT.csv</code> file and it is one of the <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> input files for the runs used for quantitation (typically MS<span class="math inline">\(^E\)</span> mode)</p>
<p>Prior to the database search, randomised entries are added to the database to allow <em>PLGS</em> to compute <em>protein false positive rate</em>. The randomised entries can either be added automatically or manually, using the <em>Randomise Databank</em> function in the <em>Databank admin tool</em>. To properly prepare the files for <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>, the user has to add randomised entries manually via <em>Databank admin tool</em>, since only then randomised entries identified in the database search will be displayed in the <em>csv</em> output. The following figures demonstrate how to create a randomised databank manually using one randomised entry per regular entry.</p>
<p><img src="Figures/PLGS_create_databank1.jpg" alt="Databank creation in PLGS." id="fig:plgs4"><img src="Figures/PLGS_db_search_options.jpg" alt="Databank search options in PLGS." id="fig:plgs5"></p>
<p>The user is also expected to use a minimum of 1 fragment per peptide, 3 fragments per protein and 1 peptide per protein identification thresholds and 100% <em>False Positive Rate</em><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> for protein identification during database search for all of the acquisitions in the analysis as demonstrated in <a href="#fig:plgs3">figure</a>. This allows to maximise the number of identified peptides from the randomised part of the database, needed to estimate peptide identifications statistics. The total list of identified peptides is given in <code>final_peptide.csv</code> files. A single <code>final_peptide.csv</code> file has to be supplied to <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> for every run in the analysis (for both identification and quantitation runs).</p>
<p>More details and screenshots are available in a separate document available at <a href="https://lgatto.github.com/synapter/" class="uri">https://lgatto.github.com/synapter/</a>.</p>
</div>
<div id="sec:synapter" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:synapter" class="anchor"></a>HDMS<span class="math inline">\(^E\)</span>/MS<span class="math inline">\(^E\)</span> data analysis</h2>
<p>The analysis of pairs of HDMS<span class="math inline">\(^E\)</span> and MS<span class="math inline">\(^E\)</span> data files is based on the following rationale – combine strengths or each approach by matching high quality HDMS<span class="math inline">\(^E\)</span> identifications to quantified MS<span class="math inline">\(^E\)</span> EMRTs applying the following algorithm:</p>
<ol style="list-style-type: decimal">
<li>Apply various peptide filters to HDMS<span class="math inline">\(^E\)</span> and MS<span class="math inline">\(^E\)</span> peptides to obtain two sets of reliably identified unique proteotypic peptides.</li>
<li>Use shared HDMS<span class="math inline">\(^E\)</span> and MS<span class="math inline">\(^E\)</span> peptides to model the deviations in retention time between the two mass spectrometer runs.</li>
<li>Optimise the parameters that will be used to optimally match all HDMS<span class="math inline">\(^E\)</span> peptides and quantified MS<span class="math inline">\(^E\)</span> EMRTs using a grid search.</li>
<li>Using the best parameters, match identified HDMS<span class="math inline">\(^E\)</span> peptides to quantified MS<span class="math inline">\(^E\)</span> EMRTs.</li>
</ol>
</div>
<div id="sec:pipelines" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:pipelines" class="anchor"></a>Different pipelines</h2>
<p>Two different pipeline are available to the user:</p>
<div id="wrapper-function" class="section level3">
<h3 class="hasAnchor">
<a href="#wrapper-function" class="anchor"></a>Wrapper function</h3>
<p>The <code>synergise</code> function is a high level wrapper that implements a suggested analysis to combine two files (see next paragraph for details). A set of parameters can be passed, although sensible defaults are provided. While the analysis is executed, a html report is created, including all result files in text spreadsheet (<code>csv</code> format) and binary R output. This level allows easy scripting for automated batch analysis. Using data from the <em><a href="http://bioconductor.org/packages/synapterdata">synapterdata</a></em> package, the following code chunk illustrates the <code>synergise</code> usage. An example report can be found online at <a href="https://lgatto.github.com/synapter/" class="uri">https://lgatto.github.com/synapter/</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"synapterdata"</span>)
hdmsefile &lt;-<span class="st"> </span><span class="kw">getHDMSeFinalPeptide</span>()[<span class="dv">2</span>]
<span class="kw">basename</span>(hdmsefile)</code></pre></div>
<pre><code>## [1] "HDMSe_101111_25fmol_UPS1_in_Ecoli_04_IA_final_peptide.csv.gz"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msefile &lt;-<span class="st"> </span><span class="kw">getMSeFinalPeptide</span>()[<span class="dv">2</span>]
<span class="kw">basename</span>(msefile)</code></pre></div>
<pre><code>## [1] "MSe_101111_25fmol_UPS1_in_Ecoli_03_IA_final_peptide.csv.gz"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msepep3dfile &lt;-<span class="st"> </span><span class="kw">getMSePep3D</span>()[<span class="dv">2</span>]
<span class="kw">basename</span>(msepep3dfile)</code></pre></div>
<pre><code>## [1] "MSe_101111_25fmol_UPS1_in_Ecoli_03_Pep3DAMRT.csv.gz"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fas &lt;-<span class="st"> </span><span class="kw">getFasta</span>()
<span class="kw">basename</span>(fas)</code></pre></div>
<pre><code>## [1] "EcoliK12_enolase_UPSsimga_NB.fasta"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## the synergise input is a (named) list of filenames
input &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">identpeptide =</span> hdmsefile,
              <span class="dt">quantpeptide =</span> msefile,
              <span class="dt">quantpep3d =</span> msepep3dfile,
              <span class="dt">fasta =</span> fas)
## a report and result files will be stored
## in the 'output' directory
output &lt;-<span class="st"> </span><span class="kw">tempdir</span>()
output</code></pre></div>
<pre><code>## [1] "/tmp/RtmpeoFMYP"</code></pre>
<!--
Not evaluating this bit because it increases
the vignette build/check over the 5 minutes
Bioconductor limit (build is 5 min, check is 12 min)
-->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw"><a href="../reference/synergise.html">synergise</a></span>(<span class="dt">filenames =</span> input, <span class="dt">outputdir =</span> output)</code></pre></div>
<!-- res ups25b from synapterdata -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Synapter.html">performance</a></span>(res)</code></pre></div>
<p>See <code><a href="../reference/synergise.html">?synergise</a></code> for details.</p>
</div>
<div id="detailed-step-by-step-analysis" class="section level3">
<h3 class="hasAnchor">
<a href="#detailed-step-by-step-analysis" class="anchor"></a>Detailed step-by-step analysis</h3>
<p>The user can have detailed control on each step of the analysis by executing each low-level function manually. This pipeline, including generation of data containers (class instances) and all available operations are available in <code><a href="../reference/Synapter.html">?Synapter</a></code>. This strategy allows the maximum flexibility to develop new unexplored approaches.</p>
</div>
</div>
<div id="sec:master" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:master" class="anchor"></a>Using <em>master</em> peptide files</h2>
<p>While analysing one MS<span class="math inline">\(^E\)</span> file against one single HDMS<span class="math inline">\(^E\)</span> file increased the total number of reliably identified and quantified features compared to each single MS<span class="math inline">\(^E\)</span> analysis, a better procedure can be applied when replicates are available. Consider the following design with two pairs of files: HDMS<span class="math inline">\(^E_1\)</span>, MS<span class="math inline">\(^E_1\)</span>, HDMS<span class="math inline">\(^E_2\)</span> and MS<span class="math inline">\(^E_2\)</span>. The classical approach would lead to combining for example, HDMS<span class="math inline">\(^E_1\)</span> and MS<span class="math inline">\(^E_1\)</span> and HDMS<span class="math inline">\(^E_2\)</span> and MS<span class="math inline">\(^E_2\)</span>. However, HDMS<span class="math inline">\(^E_1\)</span> – MS<span class="math inline">\(^E_2\)</span> and HDMS<span class="math inline">\(^E_2\)</span> – MS<span class="math inline">\(^E_1\)</span> would also be suitable, possibly leading to new identified and quantified features. Instead of repeating all possible combinations, which could hardly be applied for more replicates, we allow to merge HDMS<span class="math inline">\(^E_1\)</span> and HDMS<span class="math inline">\(^E_2\)</span> into a new <em>master</em> HDMS<span class="math inline">\(^E_{12}\)</span> and then using it to transfer identification to both MS<span class="math inline">\(^E\)</span> runs. In addition to leading to a simpler set of analyses, this approach also allows to control the false positive rate during the HDMS<span class="math inline">\(^E\)</span> merging (see section <a href="#sec:whichhdmse">Choosing HDMS<span class="math inline">\(^E\)</span> files</a>). Such <em>master</em> HDMS<span class="math inline">\(^E\)</span> files can be readily created with the <code>makeMaster</code> function, as described in section <a href="#sec:makeMaster">Generating a <em>master file</em></a>.</p>
<p>We will use data from the <em><a href="http://bioconductor.org/packages/synapterdata">synapterdata</a></em> to illustrate how to create <em>master</em> files.</p>
<div id="sec:whichhdmse" class="section level3">
<h3 class="hasAnchor">
<a href="#sec:whichhdmse" class="anchor"></a>Choosing which HDMS<span class="math inline">\(^E\)</span> files to combine</h3>
<p>In a more complex design, a greater number of HDMS<span class="math inline">\(^E\)</span> files might need to be combined. When combining files, one also accumulates false peptides assignments. The extent to which combining files increases new reliable identification at the cost of accumulating false assignments can be estimated with the <code>estimateMasterFdr</code> function.</p>
<p>To illustrate how FDR is estimated for <em>master</em> HDMS<span class="math inline">\(^E\)</span> files, let’s consider two extreme cases.</p>
<ul>
<li><p>In the first one, the two files (each with <span class="math inline">\(1000\)</span> peptides filtered at an FDR of <span class="math inline">\(0.01\)</span>) to be combined are nearly identical, sharing <span class="math inline">\(900\)</span> peptides. The combined data will have <span class="math inline">\(900 (shared) +  2 \times 100 (unique)\)</span> peptides and each file, taken separately is estimated to have <span class="math inline">\(1000 \times 0.01 = 10\)</span> false positive identifications. We thus estimate the upper FDR bound after merging the two files to be <span class="math inline">\(\frac{20}{1100} = 0.0182\)</span>.</p></li>
<li><p>In the second hypothetical case, the two files (again each with <span class="math inline">\(1000\)</span> peptides filtered at a FDR of <span class="math inline">\(0.01\)</span>) to be combined are very different and share only <span class="math inline">\(100\)</span> peptides. The combined data will have <span class="math inline">\(100 (shared) + 2 \times 900 (unique)\)</span> peptides and, as above, each file is estimated to have <span class="math inline">\(10\)</span> false discoveries. In this case, we obtain an upper FDR bound of <span class="math inline">\(\frac{20}{1900} = 0.0105\)</span>.</p></li>
</ul>
<p>In general, the final false discovery for two files will be <span class="math display">\[FDR_{master} = \frac{nfd_{1} + nfd_{2}}{union(peptides~HDMS$^E_{1}, peptides~HDMS$E_{2})}\]</span></p>
<p>where <span class="math inline">\(nfd_{i}\)</span> is the number of false discoveries in HDMS<span class="math inline">\(^E\)</span> file <span class="math inline">\(i\)</span>. Note that we do not make any assumptions about repeated identification in multiple files here.</p>
<p><code>estimateMasterFdr</code> generalised this for any number of HDMS<span class="math inline">\(^E\)</span> files and indicates the best combination at a fixed user-specified <code>masterFdr</code> level. Mandatory input is a list of HDMS<span class="math inline">\(^E\)</span> file names and a fasta database file name to filter non-unique proteotypic peptides.</p>
<p>The result of <code>estimateMasterFdr</code> stores the number of unique proteotypic peptides and FDR for all possible 57 combinations of 6 files. A summary can be printed on the console or plotted with <code>plot(cmb)</code> (see figure <a href="#fig:estimateFdrPlot">1</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## using the full set of 6 HDMSe files and a
## fasta database from the synapterdata package
inputfiles &lt;-<span class="st"> </span><span class="kw">getHDMSeFinalPeptide</span>()
fasta &lt;-<span class="st"> </span><span class="kw">getFasta</span>()
cmb &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estimateMasterFdr.html">estimateMasterFdr</a></span>(inputfiles, fasta, <span class="dt">masterFdr =</span> <span class="fl">0.02</span>)
cmb</code></pre></div>
<pre><code>## 6 files - 57 combinations
## Best combination: 4 5 
##  - 5730 proteotypic peptides
##  - 6642 unique peptides
##  - 0.017 FDR</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(cmb)</code></pre></div>
<div class="figure">
<img src="synapter_files/figure-html/estimateFdrPlot-1.png" alt="Figure illustrating the relation between the number of unique peptides in the combined HDMS$^E$ file and the resulting false discovery rate. The symbols on the figure represent the number of files for that particular combination. The dotted line is the user defined threshold for the combined FDR (`masterFdr` parameter). The best combination, i.e the one that maximises the number of unique peptides while keeping the FDR below `masterFdr` is highlighted in red." width="672"><p class="caption">
Figure illustrating the relation between the number of unique peptides in the combined HDMS<span class="math inline">\(^E\)</span> file and the resulting false discovery rate. The symbols on the figure represent the number of files for that particular combination. The dotted line is the user defined threshold for the combined FDR (<code>masterFdr</code> parameter). The best combination, i.e the one that maximises the number of unique peptides while keeping the FDR below <code>masterFdr</code> is highlighted in red.
</p>
</div>
<p>The best combination can be extracted with the <code>bestComb</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/MasterFdrResults-class.html">bestComb</a></span>(cmb)</code></pre></div>
<pre><code>## [1] 4 5</code></pre>
<p>See <code><a href="../reference/estimateMasterFdr.html">?estimateMasterFdr</a></code> and references therein for more details about the function and the returned object.</p>
</div>
<div id="sec:makeMaster" class="section level3">
<h3 class="hasAnchor">
<a href="#sec:makeMaster" class="anchor"></a>Generating a <em>master file</em>
</h3>
<p>Now that we have identified which files should be used to create the master file, we can directly pass the relevant identification files to the <code>makeMaster</code> function to generate the <em>master</em> file. The function has one mandatory input parameter, <code>pepfiles</code>, a list oh identification file names to be merged. The output is an object of class <code>MasterPeptides</code> that stores the relevant peptides from the original input files. The result can be saved to disk using <code>saveRDS</code> for further analysis, as described in section <a href="#sec:synapter">HDMS<span class="math inline">\(^E\)</span>/MS<span class="math inline">\(^E\)</span> data analysis</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">master &lt;-<span class="st"> </span><span class="kw"><a href="../reference/makeMaster.html">makeMaster</a></span>(inputfiles[<span class="kw"><a href="../reference/MasterFdrResults-class.html">bestComb</a></span>(cmb)])
master</code></pre></div>
<pre><code>## Object of class "MasterPeptides"
##  1st Master [ 1 2 ] has 6642 peptides 
##  2nd Master [ 2 1 ] has 6642 peptides 
##  [1] HDMSe_111111_50fmol_UPS1_in_Ecoli_04_IA_final_peptide.csv.gz
##  [2] HDMSe_111111_50fmol_UPS1_in_Ecoli_02_IA_final_peptide.csv.gz 
## 
##  No fragment library.</code></pre>
<p>More details can be found in the function documentation accessible with <code><a href="../reference/makeMaster.html">?makeMaster</a></code>.</p>
</div>
</div>
<div id="summary" class="section level2">
<h2 class="hasAnchor">
<a href="#summary" class="anchor"></a>Summary</h2>
<p>Two functions are needed to choose a set of identification run files and create the <em>master</em> identification run. One function enables to perform a complete identification transfer. The following table summarises all there is to know to utilise <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>’s functionality.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><code>synergise</code></td>
<td align="left">Runs the complete identification transfer</td>
</tr>
<tr class="even">
<td align="left"><code>estimateMasterFdr</code></td>
<td align="left">Chooses which files to be used to create the <em>master</em> IR</td>
</tr>
<tr class="odd">
<td align="left"><code>makeMaster</code></td>
<td align="left">Creates the <em>master</em> IR</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="sec:msnbase" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:msnbase" class="anchor"></a>Analysing complete experiments</h1>
<p>The functionality described in this section relies on the <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> package <span class="citation">(Gatto and Lilley 2012)</span>, which is installed by default with <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>. Please refer to the <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> Bioconductor web page. the associated vignettes and the respective manual pages for more details.</p>
<p>The <em><a href="http://bioconductor.org/packages/synapterdata">synapterdata</a></em> already provides preprocessed <em>PLGS</em> data. Six <code>Synapter</code> instances are available: 3 replicates (labelled <code>a</code>, <code>b</code> and <code>c</code>) of the Universal Proteomics Standard (UPS1) 48 protein mix at 25 fmol and 3 replicates at 50 fmol, in a constant <em>E. coli</em> background. The 6 files can be loaded in your working space with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(ups25a, ups25b, ups25c, ups50a, ups50b, ups50c)</code></pre></div>
<div id="sec:top3" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:top3" class="anchor"></a>Applying the <em>Top 3</em> approach</h2>
<p>We will start by describing the analysis of <code>ups25a</code> in details, and then show how to analyse all the runs using more compact code. The first step of our analysis is to convert the <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> object output (an <code>Synapter</code> instance), into a <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>-compatible object, called an <code>MSnSet</code>, that we will name <code>ms25a</code>. We can obtain a description of the <code>MSnSet</code> object by typing its name.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms25a &lt;-<span class="st"> </span><span class="kw">as</span>(ups25a, <span class="st">"MSnSet"</span>)
<span class="kw">class</span>(ups25a)[<span class="dv">1</span>]</code></pre></div>
<pre><code>## [1] "Synapter"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(ms25a)[<span class="dv">1</span>]</code></pre></div>
<pre><code>## [1] "MSnSet"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms25a</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 5642 features, 1 samples 
##   element names: exprs 
## protocolData: none
## phenoData: none
## featureData
##   featureNames: AALESTLAAITESLK IAAANVPAFVSGK ...
##     NDSALGLFNGDIGIALDR (5642 total)
##   fvarLabels: peptide.seq.MSe_101111_25fmol_UPS1_in_Ecoli_01
##     protein.Accession.MSe_101111_25fmol_UPS1_in_Ecoli_01 ...
##     qval.1.MSe_101111_25fmol_UPS1_in_Ecoli_01 (21 total)
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation: No annotation 
## - - - Processing information - - -
##  MSnbase version: 2.1.14</code></pre>
<p>It contains quantitation information about 5642 peptides for 1 sample. In the code chunk below, we update the default sample name <code>Synapter1</code> with a more meaningful one.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sampleNames</span>(ms25a)</code></pre></div>
<pre><code>## [1] "MSe_101111_25fmol_UPS1_in_Ecoli_01"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sampleNames</span>(ms25a) &lt;-<span class="st"> "ups25a"</span>
<span class="kw">sampleNames</span>(ms25a)</code></pre></div>
<pre><code>## [1] "ups25a"</code></pre>
<p>Quantitative data and meta-data, which has been acquired by <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em>, can be extracted with the <code>exprs</code> and <code>fData</code> methods.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(<span class="kw">exprs</span>(ms25a))</code></pre></div>
<pre><code>##                    ups25a
## AFLNDK                 NA
## IEAQLNDVIADLDAVR     1671
## AVFNGLINVAQHAIK      1499
## LEEVK                 664
## VALQGNMDPSMLYAPPAR   2969
## NDSALGLFNGDIGIALDR     NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(<span class="kw">fData</span>(ms25a)[, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">9</span>)])</code></pre></div>
<pre><code>##                    protein.Accession.MSe_101111_25fmol_UPS1_in_Ecoli_01
## AFLNDK                                                       MNME_ECODH
## IEAQLNDVIADLDAVR                                             MNME_ECODH
## AVFNGLINVAQHAIK                                            B1XFY9_ECODH
## LEEVK                                                      B1X7F0_ECODH
## VALQGNMDPSMLYAPPAR                                           DCUP_ECODH
## NDSALGLFNGDIGIALDR                                         B1XDM5_ECODH
##                    precursor.retT.MSe_101111_25fmol_UPS1_in_Ecoli_01
## AFLNDK                                                      33.50725
## IEAQLNDVIADLDAVR                                            84.15609
## AVFNGLINVAQHAIK                                             76.22252
## LEEVK                                                       41.40945
## VALQGNMDPSMLYAPPAR                                          67.60099
## NDSALGLFNGDIGIALDR                                          97.65882</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## all fetaure metadata
<span class="kw">fvarLabels</span>(ms25a)</code></pre></div>
<pre><code>##  [1] "peptide.seq.MSe_101111_25fmol_UPS1_in_Ecoli_01"              
##  [2] "protein.Accession.MSe_101111_25fmol_UPS1_in_Ecoli_01"        
##  [3] "protein.Description.MSe_101111_25fmol_UPS1_in_Ecoli_01"      
##  [4] "protein.falsePositiveRate.MSe_101111_25fmol_UPS1_in_Ecoli_01"
##  [5] "peptide.matchType.MSe_101111_25fmol_UPS1_in_Ecoli_01"        
##  [6] "peptide.mhp.MSe_101111_25fmol_UPS1_in_Ecoli_01"              
##  [7] "peptide.score.MSe_101111_25fmol_UPS1_in_Ecoli_01"            
##  [8] "precursor.mhp.MSe_101111_25fmol_UPS1_in_Ecoli_01"            
##  [9] "precursor.retT.MSe_101111_25fmol_UPS1_in_Ecoli_01"           
## [10] "precursor.inten.MSe_101111_25fmol_UPS1_in_Ecoli_01"          
## [11] "precursor.Mobility.MSe_101111_25fmol_UPS1_in_Ecoli_01"       
## [12] "spectrumID.MSe_101111_25fmol_UPS1_in_Ecoli_01"               
## [13] "Intensity.MSe_101111_25fmol_UPS1_in_Ecoli_01"                
## [14] "ion_ID.MSe_101111_25fmol_UPS1_in_Ecoli_01"                   
## [15] "ion_area.MSe_101111_25fmol_UPS1_in_Ecoli_01"                 
## [16] "ion_counts.MSe_101111_25fmol_UPS1_in_Ecoli_01"               
## [17] "pval.MSe_101111_25fmol_UPS1_in_Ecoli_01"                     
## [18] "Bonferroni.MSe_101111_25fmol_UPS1_in_Ecoli_01"               
## [19] "BH.MSe_101111_25fmol_UPS1_in_Ecoli_01"                       
## [20] "qval.MSe_101111_25fmol_UPS1_in_Ecoli_01"                     
## [21] "qval.1.MSe_101111_25fmol_UPS1_in_Ecoli_01"</code></pre>
<p>We will describe a how to process the data using a <em>Top 3</em> approach, where the 3 most intense peptides of each protein are used to compute the protein intensity, using the <code>topN</code> and <code>combineFeatures</code> methods. The former allows to extract the top most intense peptides (default <code>n</code> is 3) and remove all other peptides from the <code>MSnSet</code> object. The latter than aggregates the <code>n</code> most intense peptides per protein using a user-defined function (<code>sum</code>, below). Finally, we also scale protein intensity values depending on the actual number of peptides that have summed. This number of quantified peptides can be calculated (after <code>topN</code>, but before <code>combineFeatures</code>) with <code>nQuants</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms25a &lt;-<span class="st"> </span><span class="kw">topN</span>(ms25a,
              <span class="dt">groupBy =</span> <span class="kw">fData</span>(ms25a)$protein.Accession,
              <span class="dt">n =</span> <span class="dv">3</span>)
nPeps &lt;-<span class="st"> </span><span class="kw">nQuants</span>(ms25a,
                 <span class="dt">groupBy =</span> <span class="kw">fData</span>(ms25a)$protein.Accession)
ms25a &lt;-<span class="st"> </span><span class="kw">combineFeatures</span>(ms25a,
                         <span class="kw">fData</span>(ms25a)$protein.Accession,
                         <span class="st">"sum"</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>,
                         <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw">head</span>(<span class="kw">exprs</span>(ms25a))</code></pre></div>
<pre><code>##            ups25a
## 6PGL_ECODH  71555
## ABDH_ECODH  47542
## ACCA_ECODH  38249
## ACCD_ECODH  25615
## ACP_ECODH   16388
## APT_ECODH       0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(nPeps)</code></pre></div>
<pre><code>##            ups25a
## 6PGL_ECODH      3
## ABDH_ECODH      3
## ACCA_ECODH      3
## ACCD_ECODH      3
## ACP_ECODH       1
## APT_ECODH       0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## scale intensities
<span class="kw">exprs</span>(ms25a) &lt;-<span class="st"> </span><span class="kw">exprs</span>(ms25a) *<span class="st"> </span>(<span class="dv">3</span>/nPeps)
## NaN result from the division by 0, when
## no peptide was found for that protein
<span class="kw">head</span>(<span class="kw">exprs</span>(ms25a))</code></pre></div>
<pre><code>##            ups25a
## 6PGL_ECODH  71555
## ABDH_ECODH  47542
## ACCA_ECODH  38249
## ACCD_ECODH  25615
## ACP_ECODH   49164
## APT_ECODH     NaN</code></pre>
</div>
<div id="sec:batchprocessing" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:batchprocessing" class="anchor"></a>Batch processing</h2>
<p>The code chunk below repeats the above processing for the other 5 UPS1/<em>E. coli</em> runs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nms &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">paste0</span>(<span class="st">"ups"</span>, <span class="dv">25</span>, <span class="kw">c</span>(<span class="st">"b"</span>, <span class="st">"c"</span>)),
         <span class="kw">paste0</span>(<span class="st">"ups"</span>, <span class="dv">50</span>, <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>)))
tmp &lt;-<span class="st"> </span><span class="kw">sapply</span>(nms, function(.ups) {
  <span class="kw">cat</span>(<span class="st">"Processing"</span>, .ups, <span class="st">"... "</span>)
  ## get the object from workspace and convert to MSnSet
  x &lt;-<span class="st"> </span><span class="kw">get</span>(.ups, <span class="dt">envir =</span> .GlobalEnv)
  x &lt;-<span class="st"> </span><span class="kw">as</span>(x, <span class="st">"MSnSet"</span>)
  <span class="kw">sampleNames</span>(x) &lt;-<span class="st"> </span>.ups
  ## extract top 3 peptides
  x &lt;-<span class="st"> </span><span class="kw">topN</span>(x, <span class="dt">groupBy =</span> <span class="kw">fData</span>(x)$protein.Accession, <span class="dt">n =</span> <span class="dv">3</span>)
  ## calculate the number of peptides that are available
  nPeps &lt;-<span class="st"> </span><span class="kw">nQuants</span>(x, <span class="kw">fData</span>(x)$protein.Accession)
  ## sum top3 peptides into protein quantitation
  x &lt;-<span class="st"> </span><span class="kw">combineFeatures</span>(x, <span class="kw">fData</span>(x)$protein.Accession,
                       <span class="st">"sum"</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
  ## adjust protein intensity based on actual number of top peptides
  <span class="kw">exprs</span>(x) &lt;-<span class="st"> </span><span class="kw">exprs</span>(x) *<span class="st"> </span>(<span class="dv">3</span>/nPeps)
  ## adjust feature variable names for combine
  x &lt;-<span class="st"> </span><span class="kw">updateFvarLabels</span>(x, .ups)
  ## save the new MSnExp instance in the workspace
  varnm &lt;-<span class="st"> </span><span class="kw">sub</span>(<span class="st">"ups"</span>, <span class="st">"ms"</span>, .ups)
  <span class="kw">assign</span>(varnm, x, <span class="dt">envir =</span> .GlobalEnv)
  <span class="kw">cat</span>(<span class="st">"done</span><span class="ch">\n</span><span class="st">"</span>)
})</code></pre></div>
<pre><code>## Processing ups25b ... done
## Processing ups25c ... done
## Processing ups50a ... done
## Processing ups50b ... done
## Processing ups50c ... done</code></pre>
<p>We now have 6 <code>MSnSet</code> instances, containing protein quantitation for the 6 UPS/<em>E. coli</em> runs.</p>
</div>
<div id="combine" class="section level2">
<h2 class="hasAnchor">
<a href="#combine" class="anchor"></a>Combining data and filtering</h2>
<p>We now want to filter data out based on missing quantitation data, retaining proteins that have been quantified in at a least two out of three replicates. Filtering based on missing data can be done using the <code>filterNA</code> method and a maximum missing data content as defined by <code>pNA</code>. Multiple <code>MSnSet</code> instances can be combined with the <code>combine</code> method, which is described in details in the <code>MSnbase-demo</code> vignette<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. The 6 objects have appropriate distinct sample names and common feature (protein) names, which will be used to properly combine the quantitation data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms25 &lt;-<span class="st"> </span><span class="kw">combine</span>(ms25a, ms25b)
ms25 &lt;-<span class="st"> </span><span class="kw">combine</span>(ms25, ms25c)
<span class="kw">dim</span>(ms25)</code></pre></div>
<pre><code>## [1] 729   3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms25 &lt;-<span class="st"> </span><span class="kw">filterNA</span>(ms25, <span class="dt">pNA =</span> <span class="dv">1</span>/<span class="dv">3</span>)
<span class="kw">dim</span>(ms25)</code></pre></div>
<pre><code>## [1] 709   3</code></pre>
<p>Once combined and filtered, the 25 fmol group retains 709 entries with at least 2 out of 3 quantitation values, out of the 729 total number of proteins.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms50 &lt;-<span class="st"> </span><span class="kw">combine</span>(ms50a, ms50b)
ms50 &lt;-<span class="st"> </span><span class="kw">combine</span>(ms50, ms50c)
<span class="kw">dim</span>(ms50)</code></pre></div>
<pre><code>## [1] 729   3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ms50 &lt;-<span class="st"> </span><span class="kw">filterNA</span>(ms50, <span class="dt">pNA =</span> <span class="dv">1</span>/<span class="dv">3</span>)
<span class="kw">dim</span>(ms50)</code></pre></div>
<pre><code>## [1] 709   3</code></pre>
<p>Similarly, the 50 fmol group retains 709 entries with at least 2 out of 3 quantitation values, out of the 729 initial proteins.</p>
<p>We now combine the two subgroups into one <code>MSnSet</code> object that contains all 6 samples and filter for proteins that are observed in both groups, i.e retaining proteins with a maximum of 2/6 missing values. We also compute a summary table with the number of protein that have 4, 5, or 6 quantitation values across the 6 samples.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msUps &lt;-<span class="st"> </span><span class="kw">combine</span>(ms25, ms50)
msUps &lt;-<span class="st"> </span><span class="kw">filterNA</span>(msUps, <span class="dt">pNA =</span> <span class="dv">2</span>/<span class="dv">6</span>)
<span class="kw">head</span>(<span class="kw">exprs</span>(msUps))</code></pre></div>
<pre><code>##            ups25a ups25b ups25c ups50a ups50b ups50c
## 6PGL_ECODH  71555  62114  60655  59920  56185  53874
## ABDH_ECODH  47542  37805  36746  45570  43163  39506
## ACCA_ECODH  38249  31543  29570  30697  29656  27851
## ACCD_ECODH  25615  22247  20295  22206  19698  19819
## ACP_ECODH   49164 738365 706538 734425 712076 655842
## AROB_ECODH   5442   4050   3684   4095   4500   3879</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">apply</span>(<span class="kw">exprs</span>(msUps), <span class="dv">1</span>,
            function(.x)<span class="kw">sum</span>(!<span class="kw">is.na</span>(.x))))</code></pre></div>
<pre><code>## 
##   4   5   6 
##   6  25 674</code></pre>
<p>We obtain a final data set containing 705 proteins. Finally, we normalise protein intensities in each sample to correct for experimental loading biases and pipetting errors. To do so, we compute 6 sample medians using all constant <em>E. coli</em> background proteins and divide each protein by its respective sample mean.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ecoli &lt;-<span class="st"> </span>-<span class="kw">grep</span>(<span class="st">"ups$"</span>, <span class="kw">featureNames</span>(msUps))
meds &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="kw">exprs</span>(msUps)[ecoli, ], <span class="dv">2</span>,
              median, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)
<span class="kw">exprs</span>(msUps) &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(<span class="kw">exprs</span>(msUps), <span class="dv">1</span>,
                        <span class="st">"/"</span>, meds))</code></pre></div>
<p>This same procedure could be applied with a set of constant spikes to estimate absolute protein quantities.</p>
</div>
<div id="statistical-analysis-of-differentially-expressed-proteins" class="section level2">
<h2 class="hasAnchor">
<a href="#statistical-analysis-of-differentially-expressed-proteins" class="anchor"></a>Statistical analysis of differentially expressed proteins</h2>
<p>The UPS1 spiked-in protein mix is composed of 48 proteins, 47 of which have been observed and quantified in our final data object. In this section, we will illustrate how to analyse the 705 proteins to extract those that show differences between the two groups and show that these candidates represent the UPS1 spikes.</p>
<p>The R environment and many of the available packages allow extremely powerful statistical analysis. In this document, we will apply a standard t-test on <span class="math inline">\(log_2\)</span> transformed data for convenience, to calculate p-value for individual proteins (<code>pv</code> variable below). For best performance with small number of samples and more complex designs, we recommend the Bioconductor <em><a href="http://bioconductor.org/packages/limma">limma</a></em> package <span class="citation">(G. K. Smyth 2005)</span>. We then perform multiple comparison adjustment using the <code>qvalue</code> from the <em><a href="http://bioconductor.org/packages/qvalue">qvalue</a></em> package, that implements the method from <span class="citation">(Storey and Tibshirani 2003)</span> (<code>qv</code> variable below). The <em><a href="http://bioconductor.org/packages/multtest">multtest</a></em> package provides several other p-value adjustment methods. We will also compute <span class="math inline">\(log_2\)</span> fold-changes and illustrate the results on a volcano plot (figure <a href="#fig:volcano">2</a>). Figure <a href="#fig:hmap">3</a> illustrates the UPS1 proteins and samples on a classical heatmap.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## use log2 data for t-test
<span class="kw">exprs</span>(msUps) &lt;-<span class="st"> </span><span class="kw">log2</span>(<span class="kw">exprs</span>(msUps))
## apply a t-test and extract the p-value
pv &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="kw">exprs</span>(msUps), <span class="dv">1</span> ,
            function(x)<span class="kw">t.test</span>(x[<span class="dv">1</span>:<span class="dv">3</span>], x[<span class="dv">4</span>:<span class="dv">6</span>])$p.value)
## calculate q-values
<span class="kw">library</span>(<span class="st">"qvalue"</span>)
qv &lt;-<span class="st"> </span><span class="kw">qvalue</span>(pv)$qvalues
## calculate log2 fold-changes
lfc &lt;-<span class="st"> </span><span class="kw">apply</span>(<span class="kw">exprs</span>(msUps), <span class="dv">1</span> ,
             function(x) <span class="kw">mean</span>(x[<span class="dv">1</span>:<span class="dv">3</span>], <span class="dt">na.rm=</span><span class="ot">TRUE</span>)-<span class="kw">mean</span>(x[<span class="dv">4</span>:<span class="dv">6</span>], <span class="dt">na.rm=</span><span class="ot">TRUE</span>))
## create a summary table
res &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">cbind</span>(<span class="kw">exprs</span>(msUps), pv, qv, lfc))
## reorder based on q-values
res &lt;-<span class="st"> </span>res[<span class="kw">order</span>(res$qv), ]
knitr::<span class="kw">kable</span>(<span class="kw">head</span>(<span class="kw">round</span>(res, <span class="dv">3</span>)))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">ups25a</th>
<th align="right">ups25b</th>
<th align="right">ups25c</th>
<th align="right">ups50a</th>
<th align="right">ups50b</th>
<th align="right">ups50c</th>
<th align="right">pv</th>
<th align="right">qv</th>
<th align="right">lfc</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>P01112ups</td>
<td align="right">-0.053</td>
<td align="right">-0.015</td>
<td align="right">-0.001</td>
<td align="right">1.072</td>
<td align="right">1.118</td>
<td align="right">1.080</td>
<td align="right">0</td>
<td align="right">0.000</td>
<td align="right">-1.113</td>
</tr>
<tr class="even">
<td>P00918ups</td>
<td align="right">-0.247</td>
<td align="right">-0.201</td>
<td align="right">-0.214</td>
<td align="right">0.616</td>
<td align="right">0.667</td>
<td align="right">0.674</td>
<td align="right">0</td>
<td align="right">0.001</td>
<td align="right">-0.873</td>
</tr>
<tr class="odd">
<td>P01008ups</td>
<td align="right">0.112</td>
<td align="right">0.106</td>
<td align="right">0.178</td>
<td align="right">1.075</td>
<td align="right">1.132</td>
<td align="right">1.090</td>
<td align="right">0</td>
<td align="right">0.001</td>
<td align="right">-0.967</td>
</tr>
<tr class="even">
<td>Q06830ups</td>
<td align="right">0.174</td>
<td align="right">0.118</td>
<td align="right">0.156</td>
<td align="right">1.073</td>
<td align="right">1.095</td>
<td align="right">1.100</td>
<td align="right">0</td>
<td align="right">0.002</td>
<td align="right">-0.940</td>
</tr>
<tr class="odd">
<td>P10145ups</td>
<td align="right">-0.323</td>
<td align="right">-0.332</td>
<td align="right">-0.274</td>
<td align="right">0.689</td>
<td align="right">0.764</td>
<td align="right">0.788</td>
<td align="right">0</td>
<td align="right">0.003</td>
<td align="right">-1.057</td>
</tr>
<tr class="even">
<td>P02788ups</td>
<td align="right">0.564</td>
<td align="right">0.647</td>
<td align="right">0.601</td>
<td align="right">1.494</td>
<td align="right">1.532</td>
<td align="right">1.532</td>
<td align="right">0</td>
<td align="right">0.003</td>
<td align="right">-0.915</td>
</tr>
</tbody>
</table>
<p>In the above example, quantitation values and statistics data are saved in a summary dataframe (<code>res</code>), that can be exported to a comma-separated spreadsheet with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write.csv</span>(res, <span class="dt">file =</span> <span class="st">"upsResults.csv"</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(res$lfc, -<span class="kw">log10</span>(res$qv),
     <span class="dt">col =</span> <span class="kw">ifelse</span>(<span class="kw">grepl</span>(<span class="st">"ups$"</span>, <span class="kw">rownames</span>(res)),
       <span class="st">"#4582B3AA"</span>,
       <span class="st">"#A1A1A180"</span>),
     <span class="dt">pch =</span> <span class="dv">19</span>,
     <span class="dt">xlab =</span> <span class="kw">expression</span>(log[<span class="dv">2</span>]~fold-change),
     <span class="dt">ylab =</span> <span class="kw">expression</span>(-log[<span class="dv">10</span>]~q-value))
<span class="kw">grid</span>()
<span class="kw">abline</span>(<span class="dt">v =</span> -<span class="dv">1</span>, <span class="dt">lty =</span> <span class="st">"dotted"</span>)
<span class="kw">abline</span>(<span class="dt">h =</span> -<span class="kw">log10</span>(<span class="fl">0.1</span>), <span class="dt">lty =</span> <span class="st">"dotted"</span>)
<span class="kw">legend</span>(<span class="st">"topright"</span>, <span class="kw">c</span>(<span class="st">"UPS"</span>, <span class="st">"E. coli"</span>),
       <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">"#4582B3AA"</span>, <span class="st">"#A1A1A1AA"</span>),
       <span class="dt">pch =</span> <span class="dv">19</span>, <span class="dt">bty =</span> <span class="st">"n"</span>)</code></pre></div>
<div class="figure">
<img src="synapter_files/figure-html/volcano-1.png" alt="Volcano plot. On the volcano plot, each protein is represented by a dot and positioned according to its $log_2$ fold-change along the x axis and $-log_{10}$ of its q-value along the y axis. Proteins with large fold-changes are positioned on the sides of the plot, while proteins with low q-values are at the top of the figure. The most promising candidates are this located on the top corners. In our case, the UPS proteins (in blue) have $log2$ fold-changes around -1 (vertical dotted line), as expected. The horizontal dotted line represents a q-value threshold of 0.10." width="672"><p class="caption">
Volcano plot. On the volcano plot, each protein is represented by a dot and positioned according to its <span class="math inline">\(log_2\)</span> fold-change along the x axis and <span class="math inline">\(-log_{10}\)</span> of its q-value along the y axis. Proteins with large fold-changes are positioned on the sides of the plot, while proteins with low q-values are at the top of the figure. The most promising candidates are this located on the top corners. In our case, the UPS proteins (in blue) have <span class="math inline">\(log2\)</span> fold-changes around -1 (vertical dotted line), as expected. The horizontal dotted line represents a q-value threshold of 0.10.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">heatmap</span>(<span class="kw">exprs</span>(msUps)[<span class="kw">grep</span>(<span class="st">"ups"</span>,<span class="kw">featureNames</span>(msUps)), ])</code></pre></div>
<div class="figure">
<img src="synapter_files/figure-html/hmap-1.png" alt="A heatmap of all UPS1 proteins present in the final data set." width="672"><p class="caption">
A heatmap of all UPS1 proteins present in the final data set.
</p>
</div>
<table class="table">
<caption>UPS1 proteins.</caption>
<thead><tr class="header">
<th></th>
<th align="right">ups25a</th>
<th align="right">ups25b</th>
<th align="right">ups25c</th>
<th align="right">ups50a</th>
<th align="right">ups50b</th>
<th align="right">ups50c</th>
<th align="right">pv</th>
<th align="right">qv</th>
<th align="right">lfc</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>P01112ups</td>
<td align="right">-0.053</td>
<td align="right">-0.015</td>
<td align="right">-0.001</td>
<td align="right">1.072</td>
<td align="right">1.118</td>
<td align="right">1.080</td>
<td align="right">0.000</td>
<td align="right">0.000</td>
<td align="right">-1.113</td>
</tr>
<tr class="even">
<td>P00918ups</td>
<td align="right">-0.247</td>
<td align="right">-0.201</td>
<td align="right">-0.214</td>
<td align="right">0.616</td>
<td align="right">0.667</td>
<td align="right">0.674</td>
<td align="right">0.000</td>
<td align="right">0.001</td>
<td align="right">-0.873</td>
</tr>
<tr class="odd">
<td>P01008ups</td>
<td align="right">0.112</td>
<td align="right">0.106</td>
<td align="right">0.178</td>
<td align="right">1.075</td>
<td align="right">1.132</td>
<td align="right">1.090</td>
<td align="right">0.000</td>
<td align="right">0.001</td>
<td align="right">-0.967</td>
</tr>
<tr class="even">
<td>Q06830ups</td>
<td align="right">0.174</td>
<td align="right">0.118</td>
<td align="right">0.156</td>
<td align="right">1.073</td>
<td align="right">1.095</td>
<td align="right">1.100</td>
<td align="right">0.000</td>
<td align="right">0.002</td>
<td align="right">-0.940</td>
</tr>
<tr class="odd">
<td>P10145ups</td>
<td align="right">-0.323</td>
<td align="right">-0.332</td>
<td align="right">-0.274</td>
<td align="right">0.689</td>
<td align="right">0.764</td>
<td align="right">0.788</td>
<td align="right">0.000</td>
<td align="right">0.003</td>
<td align="right">-1.057</td>
</tr>
<tr class="even">
<td>P02788ups</td>
<td align="right">0.564</td>
<td align="right">0.647</td>
<td align="right">0.601</td>
<td align="right">1.494</td>
<td align="right">1.532</td>
<td align="right">1.532</td>
<td align="right">0.000</td>
<td align="right">0.003</td>
<td align="right">-0.915</td>
</tr>
<tr class="odd">
<td>P02753ups</td>
<td align="right">-1.901</td>
<td align="right">-1.822</td>
<td align="right">-1.906</td>
<td align="right">-1.006</td>
<td align="right">-0.919</td>
<td align="right">-0.876</td>
<td align="right">0.000</td>
<td align="right">0.005</td>
<td align="right">-0.943</td>
</tr>
<tr class="even">
<td>P01375ups</td>
<td align="right">0.812</td>
<td align="right">0.930</td>
<td align="right">0.963</td>
<td align="right">1.825</td>
<td align="right">1.756</td>
<td align="right">1.692</td>
<td align="right">0.000</td>
<td align="right">0.008</td>
<td align="right">-0.856</td>
</tr>
<tr class="odd">
<td>P69905ups</td>
<td align="right">-1.440</td>
<td align="right">-1.563</td>
<td align="right">-1.513</td>
<td align="right">-0.637</td>
<td align="right">-0.582</td>
<td align="right">-0.579</td>
<td align="right">0.000</td>
<td align="right">0.008</td>
<td align="right">-0.906</td>
</tr>
<tr class="even">
<td>P00167ups</td>
<td align="right">0.869</td>
<td align="right">0.890</td>
<td align="right">0.975</td>
<td align="right">1.923</td>
<td align="right">1.963</td>
<td align="right">1.938</td>
<td align="right">0.000</td>
<td align="right">0.011</td>
<td align="right">-1.030</td>
</tr>
<tr class="odd">
<td>P12081ups</td>
<td align="right">-0.094</td>
<td align="right">0.097</td>
<td align="right">-0.022</td>
<td align="right">0.936</td>
<td align="right">1.038</td>
<td align="right">1.047</td>
<td align="right">0.000</td>
<td align="right">0.011</td>
<td align="right">-1.013</td>
</tr>
<tr class="even">
<td>P00709ups</td>
<td align="right">-0.187</td>
<td align="right">-0.308</td>
<td align="right">-0.324</td>
<td align="right">0.424</td>
<td align="right">0.505</td>
<td align="right">0.508</td>
<td align="right">0.000</td>
<td align="right">0.012</td>
<td align="right">-0.752</td>
</tr>
<tr class="odd">
<td>O00762ups</td>
<td align="right">0.432</td>
<td align="right">0.267</td>
<td align="right">0.264</td>
<td align="right">1.086</td>
<td align="right">1.212</td>
<td align="right">1.214</td>
<td align="right">0.000</td>
<td align="right">0.012</td>
<td align="right">-0.850</td>
</tr>
<tr class="even">
<td>P05413ups</td>
<td align="right">-0.173</td>
<td align="right">-0.395</td>
<td align="right">-0.284</td>
<td align="right">0.576</td>
<td align="right">0.680</td>
<td align="right">0.689</td>
<td align="right">0.001</td>
<td align="right">0.024</td>
<td align="right">-0.932</td>
</tr>
<tr class="odd">
<td>P00441ups</td>
<td align="right">-0.227</td>
<td align="right">-0.414</td>
<td align="right">-0.391</td>
<td align="right">0.289</td>
<td align="right">0.413</td>
<td align="right">0.406</td>
<td align="right">0.001</td>
<td align="right">0.027</td>
<td align="right">-0.714</td>
</tr>
<tr class="even">
<td>P04040ups</td>
<td align="right">-0.065</td>
<td align="right">0.142</td>
<td align="right">0.211</td>
<td align="right">1.094</td>
<td align="right">1.245</td>
<td align="right">1.237</td>
<td align="right">0.001</td>
<td align="right">0.027</td>
<td align="right">-1.096</td>
</tr>
<tr class="odd">
<td>P02787ups</td>
<td align="right">0.003</td>
<td align="right">0.148</td>
<td align="right">0.066</td>
<td align="right">1.504</td>
<td align="right">1.533</td>
<td align="right">1.238</td>
<td align="right">0.001</td>
<td align="right">0.033</td>
<td align="right">-1.353</td>
</tr>
<tr class="even">
<td>P10636-8ups</td>
<td align="right">0.727</td>
<td align="right">0.534</td>
<td align="right">0.558</td>
<td align="right">1.493</td>
<td align="right">1.502</td>
<td align="right">1.576</td>
<td align="right">0.001</td>
<td align="right">0.033</td>
<td align="right">-0.917</td>
</tr>
<tr class="odd">
<td>P06396ups</td>
<td align="right">0.228</td>
<td align="right">0.299</td>
<td align="right">0.037</td>
<td align="right">1.179</td>
<td align="right">1.268</td>
<td align="right">1.298</td>
<td align="right">0.002</td>
<td align="right">0.036</td>
<td align="right">-1.061</td>
</tr>
<tr class="even">
<td>P16083ups</td>
<td align="right">-0.179</td>
<td align="right">-0.407</td>
<td align="right">-0.282</td>
<td align="right">1.169</td>
<td align="right">1.149</td>
<td align="right">1.168</td>
<td align="right">0.002</td>
<td align="right">0.040</td>
<td align="right">-1.452</td>
</tr>
<tr class="odd">
<td>P02768ups</td>
<td align="right">0.554</td>
<td align="right">0.340</td>
<td align="right">0.396</td>
<td align="right">1.355</td>
<td align="right">1.426</td>
<td align="right">1.408</td>
<td align="right">0.002</td>
<td align="right">0.041</td>
<td align="right">-0.966</td>
</tr>
<tr class="even">
<td>P01127ups</td>
<td align="right">0.330</td>
<td align="right">0.145</td>
<td align="right">0.216</td>
<td align="right">1.183</td>
<td align="right">1.183</td>
<td align="right">1.213</td>
<td align="right">0.002</td>
<td align="right">0.045</td>
<td align="right">-0.963</td>
</tr>
<tr class="odd">
<td>P08758ups</td>
<td align="right">0.273</td>
<td align="right">0.094</td>
<td align="right">0.081</td>
<td align="right">1.136</td>
<td align="right">1.183</td>
<td align="right">1.158</td>
<td align="right">0.003</td>
<td align="right">0.048</td>
<td align="right">-1.010</td>
</tr>
<tr class="even">
<td>P00915ups</td>
<td align="right">0.055</td>
<td align="right">-0.182</td>
<td align="right">0.063</td>
<td align="right">1.100</td>
<td align="right">1.137</td>
<td align="right">1.157</td>
<td align="right">0.004</td>
<td align="right">0.058</td>
<td align="right">-1.153</td>
</tr>
<tr class="odd">
<td>P15559ups</td>
<td align="right">0.118</td>
<td align="right">-0.088</td>
<td align="right">-0.079</td>
<td align="right">0.876</td>
<td align="right">0.934</td>
<td align="right">0.883</td>
<td align="right">0.003</td>
<td align="right">0.058</td>
<td align="right">-0.914</td>
</tr>
<tr class="even">
<td>P55957ups</td>
<td align="right">-1.083</td>
<td align="right">-1.461</td>
<td align="right">-1.329</td>
<td align="right">-0.348</td>
<td align="right">-0.393</td>
<td align="right">-0.181</td>
<td align="right">0.004</td>
<td align="right">0.058</td>
<td align="right">-0.984</td>
</tr>
<tr class="odd">
<td>P62988ups</td>
<td align="right">0.513</td>
<td align="right">0.270</td>
<td align="right">0.367</td>
<td align="right">1.289</td>
<td align="right">1.293</td>
<td align="right">1.236</td>
<td align="right">0.004</td>
<td align="right">0.064</td>
<td align="right">-0.889</td>
</tr>
<tr class="even">
<td>P01031ups</td>
<td align="right">-0.407</td>
<td align="right">-0.648</td>
<td align="right">-0.639</td>
<td align="right">0.628</td>
<td align="right">0.636</td>
<td align="right">0.633</td>
<td align="right">0.004</td>
<td align="right">0.064</td>
<td align="right">-1.197</td>
</tr>
<tr class="odd">
<td>P61626ups</td>
<td align="right">-0.096</td>
<td align="right">-0.363</td>
<td align="right">-0.320</td>
<td align="right">0.619</td>
<td align="right">0.681</td>
<td align="right">0.669</td>
<td align="right">0.006</td>
<td align="right">0.086</td>
<td align="right">-0.917</td>
</tr>
<tr class="even">
<td>P51965ups</td>
<td align="right">-0.893</td>
<td align="right">-1.182</td>
<td align="right">-1.301</td>
<td align="right">0.017</td>
<td align="right">-0.039</td>
<td align="right">-0.009</td>
<td align="right">0.011</td>
<td align="right">0.143</td>
<td align="right">-1.115</td>
</tr>
<tr class="odd">
<td>P01344ups</td>
<td align="right">-0.044</td>
<td align="right">-0.397</td>
<td align="right">-0.060</td>
<td align="right">0.570</td>
<td align="right">0.721</td>
<td align="right">0.642</td>
<td align="right">0.011</td>
<td align="right">0.149</td>
<td align="right">-0.811</td>
</tr>
<tr class="even">
<td>P01579ups</td>
<td align="right">-0.948</td>
<td align="right">-0.716</td>
<td align="right">-0.660</td>
<td align="right">-0.257</td>
<td align="right">-0.254</td>
<td align="right">-0.165</td>
<td align="right">0.016</td>
<td align="right">0.204</td>
<td align="right">-0.549</td>
</tr>
<tr class="odd">
<td>P41159ups</td>
<td align="right">0.285</td>
<td align="right">-0.206</td>
<td align="right">-0.245</td>
<td align="right">0.776</td>
<td align="right">0.856</td>
<td align="right">1.030</td>
<td align="right">0.018</td>
<td align="right">0.215</td>
<td align="right">-0.943</td>
</tr>
<tr class="even">
<td>P62937ups</td>
<td align="right">-1.375</td>
<td align="right">-0.691</td>
<td align="right">-1.117</td>
<td align="right">0.312</td>
<td align="right">0.380</td>
<td align="right">0.262</td>
<td align="right">0.018</td>
<td align="right">0.215</td>
<td align="right">-1.379</td>
</tr>
<tr class="odd">
<td>P68871ups</td>
<td align="right">-0.206</td>
<td align="right">-0.440</td>
<td align="right">-0.589</td>
<td align="right">0.374</td>
<td align="right">0.359</td>
<td align="right">0.358</td>
<td align="right">0.020</td>
<td align="right">0.218</td>
<td align="right">-0.775</td>
</tr>
<tr class="even">
<td>P08263ups</td>
<td align="right">-1.113</td>
<td align="right">-0.642</td>
<td align="right">-1.517</td>
<td align="right">0.188</td>
<td align="right">0.254</td>
<td align="right">0.279</td>
<td align="right">0.033</td>
<td align="right">0.302</td>
<td align="right">-1.331</td>
</tr>
<tr class="odd">
<td>P99999ups</td>
<td align="right">-1.202</td>
<td align="right">-1.992</td>
<td align="right">-1.953</td>
<td align="right">-0.899</td>
<td align="right">-0.192</td>
<td align="right">-0.838</td>
<td align="right">0.036</td>
<td align="right">0.316</td>
<td align="right">-1.073</td>
</tr>
<tr class="even">
<td>P10599ups</td>
<td align="right">-0.875</td>
<td align="right">-1.133</td>
<td align="right">0.166</td>
<td align="right">1.387</td>
<td align="right">0.897</td>
<td align="right">0.758</td>
<td align="right">0.037</td>
<td align="right">0.317</td>
<td align="right">-1.628</td>
</tr>
<tr class="odd">
<td>P02144ups</td>
<td align="right">-0.963</td>
<td align="right">-0.121</td>
<td align="right">-0.075</td>
<td align="right">0.992</td>
<td align="right">1.059</td>
<td align="right">1.000</td>
<td align="right">0.039</td>
<td align="right">0.324</td>
<td align="right">-1.403</td>
</tr>
<tr class="even">
<td>P01133ups</td>
<td align="right">-0.796</td>
<td align="right">0.011</td>
<td align="right">-0.382</td>
<td align="right">0.529</td>
<td align="right">0.564</td>
<td align="right">0.499</td>
<td align="right">0.058</td>
<td align="right">0.434</td>
<td align="right">-0.920</td>
</tr>
<tr class="odd">
<td>P02741ups</td>
<td align="right">-0.265</td>
<td align="right">-1.165</td>
<td align="right">-1.088</td>
<td align="right">0.309</td>
<td align="right">0.323</td>
<td align="right">0.302</td>
<td align="right">0.057</td>
<td align="right">0.434</td>
<td align="right">-1.151</td>
</tr>
<tr class="even">
<td>P61769ups</td>
<td align="right">-0.656</td>
<td align="right">-0.151</td>
<td align="right">-0.160</td>
<td align="right">0.725</td>
<td align="right">0.375</td>
<td align="right">-0.029</td>
<td align="right">0.073</td>
<td align="right">0.465</td>
<td align="right">-0.679</td>
</tr>
<tr class="odd">
<td>P63165ups</td>
<td align="right">-0.984</td>
<td align="right">0.080</td>
<td align="right">0.220</td>
<td align="right">1.074</td>
<td align="right">1.124</td>
<td align="right">1.112</td>
<td align="right">0.073</td>
<td align="right">0.465</td>
<td align="right">-1.332</td>
</tr>
<tr class="even">
<td>O76070ups</td>
<td align="right">-0.457</td>
<td align="right">0.253</td>
<td align="right">0.328</td>
<td align="right">0.881</td>
<td align="right">0.802</td>
<td align="right">0.935</td>
<td align="right">0.077</td>
<td align="right">0.479</td>
<td align="right">-0.831</td>
</tr>
<tr class="odd">
<td>P06732ups</td>
<td align="right">1.505</td>
<td align="right">0.541</td>
<td align="right">0.556</td>
<td align="right">1.318</td>
<td align="right">1.358</td>
<td align="right">1.382</td>
<td align="right">0.267</td>
<td align="right">0.498</td>
<td align="right">-0.485</td>
</tr>
<tr class="even">
<td>P63279ups</td>
<td align="right">-1.864</td>
<td align="right">-3.085</td>
<td align="right">-1.577</td>
<td align="right">-0.643</td>
<td align="right">-0.680</td>
<td align="right">-0.687</td>
<td align="right">0.083</td>
<td align="right">0.498</td>
<td align="right">-1.505</td>
</tr>
<tr class="odd">
<td>P09211ups</td>
<td align="right">1.728</td>
<td align="right">-1.862</td>
<td align="right">-1.840</td>
<td align="right">-0.762</td>
<td align="right">-0.328</td>
<td align="right">-0.654</td>
<td align="right">0.955</td>
<td align="right">0.586</td>
<td align="right">-0.077</td>
</tr>
</tbody>
</table>
<p>A total 29 proteins show a statistically different pattern between the two groups, at a false discovery rate of 10%. Table <a href="#tab:upstab">upstab</a> summarises the results for all UPS1 proteins.</p>
</div>
</div>
<div id="sec:sessionInfo" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:sessionInfo" class="anchor"></a>Session information</h1>
<p>All software and respective versions used to produce this document are listed below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sessionInfo</span>()</code></pre></div>
<pre><code>## R version 3.3.3 (2017-03-06)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## locale:
##  [1] LC_CTYPE=de_DE.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=de_DE.UTF-8        LC_COLLATE=de_DE.UTF-8    
##  [5] LC_MONETARY=de_DE.UTF-8    LC_MESSAGES=de_DE.UTF-8   
##  [7] LC_PAPER=de_DE.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=de_DE.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats     graphics  grDevices utils     datasets  methods  
## [8] base     
## 
## other attached packages:
##  [1] qvalue_2.6.0        BiocStyle_2.2.1     synapterdata_1.13.2
##  [4] synapter_1.99.0     MSnbase_2.1.14      ProtGenerics_1.6.0 
##  [7] BiocParallel_1.8.1  mzR_2.9.10          Rcpp_0.12.10       
## [10] Biobase_2.34.0      BiocGenerics_0.20.0
## 
## loaded via a namespace (and not attached):
##  [1] reshape2_1.4.2        splines_3.3.3         lattice_0.20-34      
##  [4] colorspace_1.3-2      htmltools_0.3.5       stats4_3.3.3         
##  [7] yaml_2.1.14           vsn_3.42.3            XML_3.98-1.6         
## [10] survival_2.40-1       affy_1.52.0           RColorBrewer_1.1-2   
## [13] cleaver_1.12.0        affyio_1.44.0         foreach_1.4.3        
## [16] plyr_1.8.4            mzID_1.12.0           stringr_1.2.0        
## [19] zlibbioc_1.20.0       Biostrings_2.42.1     munsell_0.4.3        
## [22] pcaMethods_1.66.0     gtable_0.2.0          codetools_0.2-15     
## [25] evaluate_0.10         knitr_1.15.1          IRanges_2.8.2        
## [28] doParallel_1.0.10     BiocInstaller_1.24.0  highr_0.6            
## [31] preprocessCore_1.36.0 readr_1.1.0           scales_0.4.1         
## [34] backports_1.0.5       limma_3.30.13         S4Vectors_0.12.2     
## [37] XVector_0.14.1        impute_1.48.0         ggplot2_2.2.1        
## [40] hms_0.3               digest_0.6.12         stringi_1.1.3        
## [43] grid_3.3.3            rprojroot_1.2         tools_3.3.3          
## [46] magrittr_1.5          lazyeval_0.2.0        tibble_1.3.0         
## [49] MASS_7.3-45           Matrix_1.2-8          rmarkdown_1.4        
## [52] iterators_1.0.8       R6_2.2.0              MALDIquant_1.16.2    
## [55] multtest_2.30.0</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-Bond2013">
<p>Bond, Nicholas James, Pavel Vyacheslavovich Shliaha, Kathryn S. Lilley, and Laurent Gatto. 2013. “Improving Qualitative and Quantitative Performance for Ms<span class="math inline">\(^E\)</span>-Based Label Free Proteomics.” <em>Journal of Proteome Research</em> 12 (6). doi:<a href="https://doi.org/10.1021/pr300776t">10.1021/pr300776t</a>.</p>
</div>
<div id="ref-Gatto2012">
<p>Gatto, Laurent, and Kathryn S Lilley. 2012. “MSnbase – an R/Bioconductor Package for Isobaric Tagged Mass Spectrometry Data Visualization, Processing and Quantitation.” <em>Bioinformatics</em> 28 (2): 288–9. doi:<a href="https://doi.org/10.1093/bioinformatics/btr645">10.1093/bioinformatics/btr645</a>.</p>
</div>
<div id="ref-Gentleman2004">
<p>Gentleman, Robert C, Vincent J Carey, Douglas M Bates, Ben Bolstad, Marcel Dettling, Sandrine Dudoit, Byron Ellis, et al. 2004. “Bioconductor: Open Software Development for Computational Biology and Bioinformatics.” <em>Genome Biol</em> 5 (10): R80. doi:<a href="https://doi.org/10.1186/gb-2004-5-10-r80">10.1186/gb-2004-5-10-r80</a>.</p>
</div>
<div id="ref-PLGS2009">
<p>Li, G Z, J P Vissers, J C Silva, D Golick, M V Gorenstein, and S J Geromanos. 2009. “Database Searching and Accounting of Multiplexed Precursor and Product Ion Spectra from the Data Independent Analysis of Simple and Complex Peptide Mixtures.” <em>Proteomics</em> 9 (6): 1696–1719. doi:<a href="https://doi.org/10.1002/pmic.200800564">10.1002/pmic.200800564</a>.</p>
</div>
<div id="ref-R">
<p>R Core Team. 2012. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="http://www.R-project.org/" class="uri">http://www.R-project.org/</a>.</p>
</div>
<div id="ref-Shliaha2013">
<p>Shliaha, Pavel Vyacheslavovich, Nicholas James Bond, Laurent Gatto, and Kathryn S. Lilley. 2013. “The Effects of Travelling Wave Ion Mobility Separation on Data Independent Acquisition in Proteomics Studies.” <em>Journal of Proteome Research</em> 2 (6). doi:<a href="https://doi.org/10.1021/pr300775k">10.1021/pr300775k</a>.</p>
</div>
<div id="ref-limma">
<p>Smyth, Gordon K. 2005. “Limma: Linear Models for Microarray Data.” In <em>Bioinformatics and Computational Biology Solutions Using R and Bioconductor</em>, edited by R. Gentleman, V. Carey, S. Dudoit, R. Irizarry, and W. Huber, 397–420. New York: Springer.</p>
</div>
<div id="ref-Storey2003">
<p>Storey, John D., and Robert Tibshirani. 2003. “Statistical Significance for Genomewide Studies.” <em>Proceedings of the National Academy of Sciences of the United States of America</em> 100 (16): 9440–5. doi:<a href="https://doi.org/10.1073/pnas.1530509100">10.1073/pnas.1530509100</a>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://www.r-project.org/" class="uri">https://www.r-project.org/</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="https://www.bioconductor.org/" class="uri">https://www.bioconductor.org/</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://bioconductor.org/packages/synapter/" class="uri">https://bioconductor.org/packages/synapter/</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>This is erroneously termed false positive rate in the software and manuscript and should be considered a false discovery rate.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>The vignette is accessible from within R with <code>vignette("MSnbase-demo" package = "MSnbase")</code>.<a href="#fnref5">↩</a></p></li>
</ol>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#foreword">Foreword</a></li>
      <li><a href="#questions-and-bugs">Questions and bugs</a></li>
      <li>
<a href="#sec:intro">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:bkg">Background</a></li>
      <li><a href="#sec:install">Installation</a></li>
      </ul>
</li>
      <li>
<a href="#sec:analysis">Data analysis using <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em></a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:input">Preparing the input data</a></li>
      <li><a href="#sec:synapter">HDMS<span class="math inline">\(^E\)</span>/MS<span class="math inline">\(^E\)</span> data analysis</a></li>
      <li><a href="#sec:pipelines">Different pipelines</a></li>
      <li><a href="#sec:master">Using <em>master</em> peptide files</a></li>
      <li><a href="#summary">Summary</a></li>
      </ul>
</li>
      <li>
<a href="#sec:msnbase">Analysing complete experiments</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:top3">Applying the <em>Top 3</em> approach</a></li>
      <li><a href="#sec:batchprocessing">Batch processing</a></li>
      <li><a href="#combine">Combining data and filtering</a></li>
      <li><a href="#statistical-analysis-of-differentially-expressed-proteins">Statistical analysis of differentially expressed proteins</a></li>
      </ul>
</li>
      <li><a href="#sec:sessionInfo">Session information</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Laurent Gatto, Nick J. Bond, Pavel V. Shliaha, Sebastian Gibb.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
