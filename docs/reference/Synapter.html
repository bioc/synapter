<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Class "Synapter" — Synapter • synapter</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script>

<!-- sticky kit -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>



<meta property="og:title" content="Class "Synapter" — Synapter" />

<meta property="og:description" content="A reference class to store, manage and process Synapt G2 data
  to combine identification and quantitation results.
The data, intermediate and final results are stored together
  in such a ad-how container called a class. In the frame of the
  analysis of a set of 3 or 5 data files, namely as identification peptide,
  a quantitation peptide and a quantitation Pep3D, and identification fragments
  and quantitation spectra, such a container is created
  and populated, updated according to the user's instructions
  and used to display and export results.
The functionality of the synapter package implemented in the
  Synapter class in described in the Details section
  below. Documentation for the individual methods is provided in the
  Methods section. Finally, a complete example of an analysis is
  provided in the Examples section, at the end of this document.
See also papers by Shliaha et al. for details about ion mobility
  separation and the manuscript describing the synapter
  methodology." />
<meta name="twitter:card" content="summary" />



<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">synapter</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">2.5.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/synapter.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/fragmentmatching.html">Fragment matching using *synapter*</a>
    </li>
    <li>
      <a href="../articles/synapter2.html">Synapter2 and synergise2</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Class "Synapter"</h1>
    
    <div class="hidden name"><code>Synapter.Rd</code></div>
    </div>

    <div class="ref-description">
    
    <p>A reference class to store, manage and process Synapt G2 data
  to combine identification and quantitation results.</p>
<p>The data, intermediate and final results are stored together
  in such a ad-how container called a class. In the frame of the
  analysis of a set of 3 or 5 data files, namely as identification peptide,
  a quantitation peptide and a quantitation Pep3D, and identification fragments
  and quantitation spectra, such a container is created
  and populated, updated according to the user's instructions
  and used to display and export results.</p>
<p>The functionality of the <code>synapter</code> package implemented in the
  <code>Synapter</code> class in described in the <em>Details</em> section
  below. Documentation for the individual methods is provided in the
  <em>Methods</em> section. Finally, a complete example of an analysis is
  provided in the <em>Examples</em> section, at the end of this document.</p>
<p>See also papers by Shliaha et al. for details about ion mobility
  separation and the manuscript describing the <code>synapter</code>
  methodology.</p>
    
    </div>

    <pre class="usage"><span class='fu'>Synapter</span>(<span class='no'>filenames</span>, <span class='no'>master</span>) <span class='co'>## creates an instance of class 'Synapter'</span></pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>filenames</th>
      <td><p>A named <code>list</code> of file names to be load. The
    names must be 'identpeptide', 'quantpeptide', 'quantpep3d' and 'fasta'
    (could be an RDS file created by <code>link{createUniquePeptideDbRds}</code>)
    and (optional 'identfragments' and 'quantspectra').
    <code>identpeptide</code> can be a <code>csv</code> final peptide file (from
    PLGS) or a saved <code>"<a href='MasterPeptides-class.html'>MasterPeptides</a>"</code> data object as
    created by <code><a href='makeMaster.html'>makeMaster</a></code> if working with <em>master</em>
    peptide data. To serialise the <code>"<a href='MasterPeptides-class.html'>MasterPeptides</a>"</code>
    instance, use the <code>saveRDS</code> function, and file extenstion
    <code>rds</code>. This master file could contain a fragment library as well. In
    this case the 'identfragments' argument would be ignored.</p></td>
    </tr>
    <tr>
      <th>master</th>
      <td><p>A <code>logical</code> that defines if the identification file
    is a <em>master</em> file. See <code><a href='makeMaster.html'>makeMaster</a></code> for details
    about this strategy.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>A <code>Synapter</code> object logs every operation that is applied to
  it. When displayed with <code>show</code> or when the name of the instance
  is typed at the R console, the original input file names, all
  operations and resulting the size of the respective data are
  displayed. This allows the user to trace the effect of respective
  operations.</p>
<p></p><h3>Loading the data</h3>
    The construction of the data and analysis container, technically
    defined as an instance or object of class <code>Synapter</code>, is created
    with the <code>Synapter</code> constructor.
    This function requires 4 or 6 files as input, namely,
    the identification final peptide csv file, the quantitation final peptide
    csv file, the quantitation Pep3D csv file (as exported from the PLGS
    software), the fasta file use for peptide identification, and optional
    the identification fragments csv file and the quantitation
    spectra xml file. The fasta file ('fasta') could be an RDS file generated by
    <code>link{createUniquePeptideDbRds}</code>, too.
    The file names need to be specified as a named list with names
    'identpeptide', 'quantpeptide', 'quantpep3d', 'fasta', 'identfragments'
    and 'quantspectra' respectively.
    These files are read and the data is stored in the newly
    created <code>Synapter</code> instance.
    The final peptide files are filtered
    to retain peptides with <code>matchType</code> corresponding to
    <code>PepFrag1</code> and <code>PepFrag2</code>, corresponding to unmodified
    round 1 and 2 peptide identification. Other types, like
    <code>NeutralLoss_NH3</code>, <code>NeutralLoss_H20</code>, <code>InSource</code>,
    <code>MissedCleavage</code> or <code>VarMod</code> are not considered in the rest
    of the analysis. The quantitation Pep3D data is filtered to retain
    <code>Function</code> equal to <code>1</code> and unique quantitation spectrum ids,
    i.e. unique entries for multiple charge states or isotopes of an EMRT
    (exact mass-retention time features).
    Then, p-values for <code>Regular</code> peptides are computed based on
    the <code>Regular</code> and <code>Random</code> database types score
    distributions, as described in  <cite>Käll et al.,
      2008a</cite>. Only unique peptide sequences are taken into account:
    in case of duplicated peptides, only one entry is kept.
    Empirical p-values are adjusted using <cite>Bonferroni</cite>
    and <cite>Benjamini and Hochberg, 1995</cite> (<code>multtest</code> package)
    and q-values are computed using the <code>qvalue</code> package
    (<cite>Storey JD and Tibshirani R., 2003 and Käll et
      al., 2008b</cite>). Only <code>Regular</code> entries are stored in the
    resulting data for subsequent analysis.
    The data tables can be exported as <code>csv</code> spreadsheets with the
    <code>writeIdentPeptides</code> and <code>writeQuantPeptides</code> methods.
    <p></p><h3>Filtering identification and quantitation peptide</h3>
    The first step of the analysis aims to match reliable peptide.
    The final peptide datasets are
    filtered based on the FDR (BH is default) using the
    <code>filterQuantPepScore</code> and  <code>filterIdentPepScore</code>
    methods. Several plots are provided to illustrate peptide score
    densities (from which p-values are estimated, <code>plotPepScores</code>;
    use <code>getPepNumbers</code> to see how many peptides were available) and
    q-values (<code>plotFdr</code>).
    Peptides matching to multiple proteins in the fasta file (non-unique
    tryptic identification and quantitation peptides) can be
    discarded with the <code>filterUniqueDbPeptides</code> method. One can
    also filter on the peptide length using <code>filterPeptideLength</code>.
    Another filtering criterion is mass accuracy. Error tolerance
    quantiles (in ppm, parts per million) can be visualised with the
    <code>plotPpmError</code> method. The values can be retrieved with
    <code>getPpmErrorQs</code>. Filtering is then done separately for
    identification and quantitation peptide data using
    <code>filterIdentPpmError</code> and <code>filterQuantPpmError</code>
    respectively. The previous plotting functions can be used again to
    visualise the resulting distribution.
    Filtering can also be performed at the level of protein false
    positive rate, as computed by the PLGS application
    (<code>protein.falsePositiveRate</code> column), which counts the
    percentage of decoy proteins that have been identified prior to the
    regular protein of interest. This can be done with the
    <code>filterIdentProtFpr</code> and <code>filterQuantProtFpr</code> methods.
    Note that this field is erroneously called a false positive rate in
    the PLGS software and the associated manuscript; it is a false
    discovery rate.
    <p></p><h3>Merging identification and quantitation peptides</h3>
    Common and reliable identification and quantitation peptides are
    then matched based on their sequences and merged using the
    <code>mergePeptides</code> method.
    <p></p><h3>Retention time modelling</h3>
    Systematic differences between identification features and
    quantitation features retention times are modelled by
    fitting a local regression (see the <code>loess</code> function for
    details), using the <code>modelRt</code> method. The smoothing parameter,
    or number of neighbour data points used the for local fit, is
    controlled by the <code>span</code> parameter that can be set in the above
    method.
    The effect of this parameter can be observed with the <code>plotRt</code>
    method, specifying <code>what = "data"</code> as parameters. The resulting
    model can then be visualised with the above method specifying
    <code>what = "model"</code>, specifying up to 3 number of standard
    deviations to plot. A histogram of retention time differences can
    be produced with the <code>plotRtDiffs</code> method.
    To visualise the feature space <code>plotFeatures</code> could be used. It
    generates one or two (if ion mobility is available) plots of
    retention time vs mass and mass vs ion mobility for each data source,
    namely, Identification data, Quantitation data and Quantitation Pep3D data.
    <p></p><h3>Intensity modelling</h3>
    Systematic differences between intensities of identification features and
    quantitation features depending on retention times are modelled by
    fitting a local regression (see the <code>loess</code> function for
    details), using the <code>modelIntensity</code> method. The smoothing parameter,
    or number of neighbour data points used the for local fit, is
    controlled by the <code>span</code> parameter that can be set in the above
    method.
    The effect of this parameter can be observed with the <code>plotIntensity</code>
    method, specifying <code>what = "data"</code> as parameters. The resulting
    model can then be visualised with the above method specifying
    <code>what = "model"</code>, specifying up to 3 number of standard
    deviations to plot.
    <p></p><h3>Grid search to optimise matching tolerances</h3>
    Matching of identification peptides and quantitation EMRTs is done
    within a mass tolerance in parts per million (ppm) and the modelled
    retention time +/- a certain number of standard deviations.
    To help in the choice of these two parameters, a grid search over a
    set of possible values is performed and performance metrics are
    recorded, to guide in the selection of a 'best' pair of parameters.
    The following metrics are computed:
    (1) the percentage of identification
    peptides that matched a single quantitation EMRT (called <code>prcntTotal</code>),
    (2) the percentage of identification peptides used in the retention time
    model that matched the quantitation EMRT corresponding to the
    correct quantitation peptide in ident/quant pair of the model
    (called <code>prcntModel</code>)
    and
    (3) the detailed about the matching of the features used for
    modelling (accessible with <code>getGridDetails</code>) and the
    corresponding <code>details</code> grid that reports the percentage of
    correct unique assignments.
    The detailed grid results specify the number of non
    matched identification peptides (0), the number of correctly (1) or
    wrongly (-1) uniquely matched identification peptides, the number of
    identification peptides that matched 2 or more peptides including
    (2+) or excluding (2-) the correct quantitation equivalent are also
    available.
    See the next section for additional details about how matching.
    The search is performed with the <code>searchGrid</code> method, possibly
    on a subset of the data (see Methods and Examples sections for
    further details).
    The parameters used for matching can be set manually with
    <code>setPpmError</code>, <code>setRtNsd</code>, <code>setImDiff</code> respectively,
    or using <code>setBestGridParams</code> to apply best parameters as defined using
    the grid search. See example and method documentation for details.
    <p></p><h3>Identification transfer: matching identification peptides and quantitation EMRTs</h3>
    The identification peptide - quantitation EMRT matching, termed
    identification transfer, is performed using the best parameters, as
    defined above with a grid search, or using user-defined parameters.
    Matching is considered successful when one and only one EMRT is
    found in the mass tolerance/retention time/ion mobility window defined
    by the error ppm, number of retention time standard deviations, and ion
    mobility difference parameters. The values of uniquely matched EMRTs are
    reported in the final <em>matched</em> dataframe that can be exported
    (see below).
    If however, none or more than one EMRTs are matched, 0 or the number of
    matches are reported.
    As identification peptides are serially individually matched to 'close'
    EMRTs, it is possible for peptides to be matched the same EMRT
    independently. Such cases are reported as -1 in the results
    dataframes.
    The results can be assess using the <code>plotEMRTtable</code> (or
    <code>getEMRTtable</code> to retrieve the values) and <code>performace</code>
    methods. The former shows the number of identification peptides assigned to
    none (0), exactly 1 (1) or more (&gt; 2) EMRTs.
    The latter method reports matched identification peptides, the number of
    (q-value and protein FPR filtered) identification and quantitation peptides.
    Matched EMRT and quantitation peptide numbers are then compared
    calculating the synapter enrichment (100 * ( synapter - quant ) / quant)
    and Venn counts.
    <p></p><h3>Remove Less Intense Peaks</h3>
    As an additional step it is possible to remove less intense peaks from the
    spectra and fragment data. Use <code>plotCumulativeNumberOfFragments</code> to
    plot the number of fragments vs the intensity and to find a good threshold.
    The <code>filterFragments</code> method could remove peaks if the intensity is
    below a specified threshold via the <code>minIntensity</code> argument. Set the
    <code>maxNumber</code> argument to keep only the <code>maxNumber</code> highest
    peaks/fragments. The <code>what</code> argument controls the data on which the
    filter is applied. Use <code>what = "fragments.ident"</code> for the
    identification fragments and <code>what = "spectra.quant"</code> for the
    quantiation spectra data.
    <p></p><h3>Fragment Matching</h3>
    After importing fragment and spectra data it is possible to
    match peaks between the identification fragments and the quantitation
    spectra using the <code>fragmentMatching</code> method.
    Use <code>setFragmentMatchingPpmTolerance</code> to set
    the maximal allowed tolerance for considering a peak as identical.
    There are two different methods to visualise the results of the fragment
    matching procedure. <code>plotFragmentMatching</code> plots the fragments and
    spectra for each considered pair.
    <code>plotFragmentMatchingPerformance</code> draws two plots. On the left panel
    you could see the performance of different thresholds for the number of
    common peaks for unique matches.  The right panel visualizes the performance
    of different differences (delta) of common peaks between the best match
    (highest number of common peaks) and the second best match in each non
    unique match group. <code>plotFragmentMatchingPerformance</code> returns the
    corresponding values invisible or use <code>fragmentMatchingPerformance</code> to
    access these data.
    Use <code>filterUniqueMatches</code> and <code>filterNonUniqueMatches</code> to remove
    unique or non unique matches below the threshold of common peaks
    respective the difference in common peaks from the MatchedEMRTs data.frame.
    <p></p><h3>Exporting and saving data</h3>
    The merged identification and quantitation peptides can be exported
    to csv using the  <code>writeMergedPeptides</code> method. Similarly, the
    matched identification peptides and quantitation EMRTs are exported
    with <code>writeMatchedEMRTs</code>.
    Complete <code>Synapter</code> instances can be serialised with
    <code>save</code>, as any R object, and reloaded with <code>load</code> for
    further analysis.
    It is possible to get the fragment and spectra data from the identification
    and quantitation run using <code>getIdentificationFragments</code> respectively
    <code>getQuantitationSpectra</code>.
    
    <h2 class="hasAnchor" id="methods"><a class="anchor" href="#methods"></a>Methods</h2>

    
    <p></p><h3>Analysis methods</h3>
    <dl class='dl-horizontal'>
      <dt>mergePeptides</dt><dd><p><code>signature(object = "Synapter")</code>: Merges
	quantitation and identification final peptide data, used to
	perform retention time modelling (see <code>modelRt</code> below).</p></dd>
    <dt>modelRt</dt><dd><p><code>signature(object = "Synapter",
	  span = "numeric")</code>: Performs local polynomial regression
	fitting (see <code>loess</code>) retention time alignment using
	<code>span</code> parameter value to control the degree of smoothing.</p></dd>
    <dt>modelIntensity</dt><dd><p><code>signature(object = "Synapter",
	  span = "numeric")</code>: Performs local polynomial regression
	fitting (see <code>loess</code>) intensity values using
	<code>span</code> parameter value to control the degree of smoothing.</p></dd>
    <dt>findEMRTs</dt><dd><p><code>signature(object = "Synapter", ppm =
	  "numeric", nsd = "numeric", imdiff = "numeric")</code>:
	Finds EMRTs matching identification peptides using <code>ppm</code>
	mass tolerance, <code>nsd</code> number of retention time standard
	deviations and <code>imdiff</code> difference in ion mobility.
  The last three parameters are optional if previously
	set with <code>setPpmError</code>, <code>setRtNsd</code>, <code>setImDiff</code>,
  or, better, <code>setBestGridParams</code> (see below).</p></dd>
    <dt>rescueEMRTs</dt><dd><p><code>signature(object = "Synapter",
    method = c("rescue", "copy"))</code>:
  The <code>method</code> parameter defined the behaviour for those
  high confidence features that where identified in both identification and
	quantitation acquisitions and used for the retention time model
	(see <code>mergePeptides</code>). Prior to version 1.1.1, these
	features were transferred from the quantitation pep3d file if
	unique matches were found, as any feature (<code>"transfer"</code>).
	As a result, those matching 0 or &gt; 1 EMRTs were
	quantified as <code>NA</code>. The default is now to <code>"rescue"</code>
	the quantitation values of these by directly retrieving the data
	from the quantification peptide data. Alternatively, the
	quantitation values for these features can be directly taken
	from the quantitation peptide data using <code>"copy"</code>, thus
	effectively bypassing identification transfer.</p></dd>
    <dt>searchGrid</dt><dd><p><code>signature(object="Synapter",
	  ppms="numeric", nsds="numeric", imdiffs = "numeric",
    subset="numeric", n = "numeric", verbose="logical")</code>:
  Performs a grid search. The
	grid is defined by the <code>ppm</code>, <code>nsd</code> and <code>imdiffs</code>
  numerical vectors, representing the sequence of values to be
	tested. Default are <code>seq(5, 20, 2)</code>, <code>seq(0.5, 5,
	  0.5)</code>, <code>seq(0.2, 2, 0.2)</code> respectively. To ignore ion mobility set
  <code>imdiffs = Inf</code>.
  <code>subset</code> and <code>n</code> allow to use a
	randomly  chosen subset of the data for the grid search to
	reduce search time. <code>subset</code> is a numeric, between 0 and 1,
	describing the percentage of data to be used; <code>n</code> specifies
	the absolute number of feature to use. The default is to use all
	data. <code>verbose</code> controls whether textual output should be
	printed to the console. (Note, the <code>mergedEMRTs</code> value used
	in internal calls to <code>findEMRTs</code> is <code>"transfer"</code> - see
	<code>findEMRTs</code> for details).</p></dd>
    <dt>fragmentMatching</dt><dd><p><code>signature(object="Synapter",
      ppm = "numeric", verbose = "logical"</code>:
      Performs a fragment matching between spectra and fragment data.
      The <code>ppm</code> argument controls the tolerance that is used to consider
      two peaks (MZ values) as identical.  If <code>verbose</code> is <code>TRUE</code>
      (default) a progress bar is shown.</p></dd>
  </dl>
    <h3>Methods to display, access and set data</h3>
    <dl class='dl-horizontal'>
    <dt>show</dt><dd><p><code>signature(object = "Synapter")</code>: Display
	<code>object</code> by printing a summary to the console.</p></dd>
    <dt>dim</dt><dd><p><code>signature(x="Synapter")</code>: Returns a <code>list</code>
	of dimensions for the identification peptide, quantitation
	peptide, merged peptides and matched features data sets.</p></dd>
    <dt>inputFiles</dt><dd><p><code>signature(object="Synapter")</code>: Returns a
	<code>character</code> of length 6 with the names of the input files
	used as <code>identpeptide</code>, <code>quantpeptide</code>,
	<code>quantpep3d</code>, <code>fasta</code>, <code>identfragments</code> and
  <code>quantspectra</code>.</p></dd>
    <dt>getLog</dt><dd><p><code>signature(object="Synapter")</code>: Returns a
	<code>character</code> of variable length with a summary of processing
	undergone by <code>object</code>.</p></dd>
    <dt>getGrid</dt><dd><p><code>signature(object="Synapter", digits =
	  "numeric")</code>: Returns a named <code>list</code> of length 3 with the
	precent of total (<code>prcntTotal</code>), percent of model
	(<code>prcntModel</code>) and detailed (<code>details</code>) grid search
	results. The <code>details</code> grid search reports the proportion
	of correctly assigned features (+1) to all unique assignments
	(+1 and -1). Values are rounded to 3 <code>digits</code> by default.</p></dd>
    <dt>getGridDetails</dt><dd><p><code>signature(object="Synapter")</code>: Returns
	a <code>list</code> of number of ..., -2, -1, 0, +1, +2, ... results
	found for each of the <code>ppm</code>/<code>nsd</code> pairs tested during
	the grid search.</p></dd>
    <dt>getBestGridValue</dt><dd><p><code>signature(object="Synapter")</code>:
	Returns a named <code>numeric</code> of length 3 with best grid values
	for the 3 searches. Names are <code>prcntTotal</code>,
	<code>prcntModel</code> and <code>details</code>.</p></dd>
    <dt>getBestGridParams</dt><dd><p><code>signature(object="Synapter")</code>:
	Returns a named <code>list</code> of matrices (<code>prcntTotal</code>,
	<code>prcntModel</code> and <code>details</code>). Each matrix gives the
	<code>ppm</code> and <code>nsd</code> pairs that yielded the best grid
	values (see <code>getBestGridValue</code> above).</p></dd>
    <dt>setBestGridParams</dt><dd><p><code>signature(object="Synapter",
	  what="character")</code>: This methods set the best parameter pair,
	as determined by <code>what</code>. Possible values are <code>auto</code>
	(default), <code>model</code>, <code>total</code> and <code>details</code>. The 3
	last ones use the (first) best parameter values as reported by
	<code>getBestGridParams</code>. <code>auto</code> uses the best <code>model</code>
	parameters and, if several best pairs exists, the one that
	maximises <code>details</code> is selected.</p></dd>
    <dt>setPepScoreFdr</dt><dd><p><code>signature(object="Synapter", fdr =
	  "numeric")</code>: Sets the peptide score false discovery rate
	(default is 0.01) threshold used by <code>filterQuantPepScore</code>
	and <code>filterIdentPepScore</code>.</p></dd>
    <dt>getPepScoreFdr</dt><dd><p><code>signature(object="Synapter")</code>: Returns
	the peptide false discrovery rate threshold.</p></dd>
    <dt>setIdentPpmError</dt><dd><p><code>signature(object="Synapter", ppm =
	  "numeric")</code>: Set the identification mass tolerance to
	<code>ppm</code> (default 10).</p></dd>
    <dt>getIdentPpmError</dt><dd><p><code>signature(object="Synapter")</code>:
	Returns the identification mass tolerance.</p></dd>
    <dt>setQuantPpmError</dt><dd><p><code>signature(object="Synapter", ppm =
	  "numeric")</code>: Set the quantitation mass tolerance to <code>ppm</code>
	(default 10).</p></dd>
    <dt>getQuantPpmError</dt><dd><p><code>signature(object="Synapter")</code>:
	Returns the quantitation mass tolerance.</p></dd>
    <dt>setPpmError</dt><dd><p><code>signature(object="Synapter", ppm =
	  "numeric")</code>: Sets the identification and quantitation mass
	tolerance <code>ppm</code> (default is 10).</p></dd>
    <dt>setLowessSpan</dt><dd><p><code>signature(object="Synapter", span =
	  "numeric")</code>: Sets the <code>loess</code> <code>span</code> parameter;
	default is 0.05.</p></dd>
    <dt>getLowessSpan</dt><dd><p><code>signature(object="Synapter")</code>: Returns
	the <code>span</code> parameter value.</p></dd>
    <dt>setRtNsd</dt><dd><p><code>signature(object="Synapter", nsd =
	  "numeric")</code>: Sets the retention time tolerance <code>nsd</code>,
	default is 2.</p></dd>
    <dt>getRtNsd</dt><dd><p><code>signature(object="Synapter")</code>: Returns the
	value of the retention time tolerance <code>nsd</code>.</p></dd>
    <dt>setImDiff</dt><dd><p><code>signature(object="Synapter", imdiff =
	  "numeric")</code>: Sets the ion mobility tolerance <code>imdiff</code>,
	default is 0.5.</p></dd>
    <dt>getImDiff</dt><dd><p><code>signature(object="Synapter")</code>: Returns the
	value of the ion mobility tolerance <code>imdiff</code>.</p></dd>
    <dt>getPpmErrorQs</dt><dd><p><code>signature(object="Synapter", qs =
	  "numeric", digits = "numeric")</code>: Returns the mass tolerance
	<code>qs</code> quantiles (default is <code>c(0.25, 0.5, 0.75, seq(0.9,
	  1, 0.01)</code>) for the identification and quantitation
	peptides. Default is 3 <code>digits</code>.</p></dd>
    <dt>getRtQs</dt><dd><p><code>signature(object="Synapter", qs =
	  "numeric", digits = "numeric")</code>: Returns the retention time
	tolerance <code>qs</code> quantiles (default is <code>c(0.25, 0.5,
	  0.75, seq(0.9, 1, 0.01)</code>) for the identification and
	quantitation peptides. Default is 3 <code>digits</code>.</p></dd>
    <dt>getPepNumbers</dt><dd><p><code>signature(object="Synapter")</code>: Returns
	the number of regular and random quantitation and identification
	peptide considered for p-value calculation and used to plot the
	score densities (see <code>plotPepScores</code>). Especially the
	difference between random and regular entries are informative in
	respect with the confidence of the random scores distribution.</p></dd>
    <dt>setFragmentMatchingPpmTolerance</dt><dd><p><code>signature(object="Synapter",
        ppm = "numeric")</code>: Sets the fragment matching mass tolerance <code>ppm</code>
        (default is 25).</p></dd>
    <dt>getFragmentMatchingPpmTolerance</dt><dd><p><code>signature(object="Synapter")</code>:
        Returns the fragment matching mass tolerance in ppm.</p></dd>
    <dt>showFdrStats</dt><dd><p><code>signature(object="Synapter", k =
	  "numeric")</code>: Returns a named <code>list</code> of length
	2 with the proportion of identification and quantitation
	peptides that are considered significant with a threshold of
	<code>k</code> (default is <code>c(0.001, 0.01, 0.5, 0.1)</code>) using raw
	and adjusted p-values/q-values.</p></dd>
    <dt>getEMRTtable</dt><dd><p><code>signature(object="Synapter")</code>: Returns a
	<code>table</code> with the number of 0, 1, 2, ... assigned EMRTs.</p></dd>
    <dt>performance</dt><dd><p><code>signatute(object="Synapter", verbose =
	  TRUE)</code>: Returns (and displays, if <code>verbose</code>) the
	performance of the synapter analysis.</p></dd>
    <dt>performance2</dt><dd><p><code>signatute(object="Synapter", verbose =
	  TRUE)</code>: Returns (and displays, if <code>verbose</code>) information
	about number of missing values and identification source of
	transfered EMRTs.</p></dd>
    <dt>fragmentMatchingPerformance</dt><dd><p><code>signature(object="Synapter",
          what = c("unique", "non-unique")</code>:
        Returns the performance of the fragment matching for <code>unqiue</code> or
        <code>non-unique</code> matches. The return valus is a <code>matrix</code> with
        seven columns. The first column <code>ncommon</code>/<code>deltacommon</code>
        contains the thresholds. Column 2 to 5 are the true positives <code>tp</code>,
        false positives <code>fp</code>, true negatives <code>tn</code>, false negatives
        <code>fn</code> for the merged peptide data. The sixth column <code>all</code> shows
        the corresponding number of peptides for all peptides
        (not just the merged ones) and the last column shows the FDR <code>fdr</code>
        for the current threshold (in that row) for the merged data.
    Please note that the FDR is overfitted/underestimated because the merged
        peptides are the peptides from the highest quality spectra were PLGS could
        easily identify the peptides. The peptides that are not present in the
        merged data are often of lower quality hence the FDR would be higher by
        trend.
    See <code>plotFragmentMatchingPerformance</code> for a graphical
        representation.</p></dd>
    </dl>
    <h3>Filters</h3>
    <dl class='dl-horizontal'>
    <dt>filterUniqueDbPeptides</dt><dd><p><code>signature(object="Synapter",
          missedCleavages = 0, IisL = TRUE, verbose = TRUE)</code>:
	This method first digests the fasta database file and keeps
	unique tryptic peptides. (NOTE: since version 1.5.3, the tryptic
	digestion uses the <code>cleaver</code> package, replacing the more
	simplistic inbuild function. The effect of this change is
  documented in https://github.com/lgatto/synapter/pull/47).
  The number of maximal missed cleavages can be set as <code>missedCleavages</code>
       (default is 0).
  If <code>IisL = TRUE</code> Isoleucin and Leucin are treated as the same aminoacid.
  In this case sequences like "ABCI", "ABCL" are removed
  because they are not unqiue anymore. If <code>IisL = FALSE</code> (default)
  "ABCI" and "ABCL" are reported as unique.
  The peptide sequences are then used as a
	filter against the identification and quantitation peptides,
	where only unique proteotyptic instances (no miscleavage allowed
	by default) are eventually kept in the <code>object</code> instance.
	This method also removes any additional duplicated peptides,
	that would not match any peptides identified in the fasta
	database.</p></dd>
    <dt>filterUniqueQuantDbPeptides</dt><dd><p><code>signature(object="Synapter",
    missedCleavages = 0, IisL = TRUE, verbose = TRUE)</code>: As
	<code>filterUniqueDbPeptides</code> for quantitation peptides only.</p></dd>
    <dt>filterUniqueIdentDbPeptides</dt><dd><p><code>signature(object="Synapter",
    missedCleavages = 0, IisL = TRUE, verbose = TRUE)</code>: As
	<code>filterUniqueDbPeptides</code> for identification peptides
	only.</p></dd>
    <dt>filterQuantPepScore</dt><dd><p><code>signature(object="Synapter", fdr
	  = "numeric", method = "character")</code>: Filters the quantitation
	peptides using <code>fdr</code> false discovery rate. <code>fdr</code> is
	missing by default and is retrieved with <code>getPepScoreFdr</code>
	automatically. If not set, default value of 0.01 is
	used. <code>method</code> defines how to performe p-value adjustment;
	one of <code>BH</code>, <code>Bonferrone</code> or <code>qval</code>. See details
	section for more information.</p></dd>
    <dt>filterIdentPepScore</dt><dd><p><code>signature(object="Synapter", fdr
	  = "numeric", method = "charactet")</code>: As
	<code>filterQuantPepScore</code>, but for identification peptides.</p></dd>
    <dt>filterQuantProtFpr</dt><dd><p><code>signature(object="Synapter", fpr
	  = "numeric")</code>: Filters quantitation peptides using the protein
	false positive rate (erroneously defined as a FPR, should be
	FDR), as reported by PLGS, using threshold set by <code>fpr</code>
	(missing by default) or retrieved by <code>getProtFpr</code>.</p></dd>
    <dt>filterIdentProtFpr</dt><dd><p><code>signature(object="Synapter", fpr =
	  "numeric")</code>: as <code>filterQuantProtFpr</code>, but for
	identification peptides.</p></dd>
    <dt>filterQuantPpmError</dt><dd><p><code>signature(object="Synapter", ppm
	  = "numeric")</code>: Filters the quantitation peptides based on the
	mass tolerance <code>ppm</code> (default missing) provided or
	retrieved automatically using <code>getPpmError</code>.</p></dd>
    <dt>filterIdentPpmError</dt><dd><p><code>signature(object="Synapter")</code>: as
	<code>filterQuantPpmError</code>, but for identification peptides.</p></dd>
    <dt>filterFragments</dt><dd><p><code>signature(object = "Synapter",
        what = c("fragments.ident", "spectra.quant"),
        minIntensity = "numeric", maxNumber = "numeric", verbose = "logical")</code>:
      Filters the spectra/fragment data using a minimal intensity threshold
      (<code>minIntensity</code>) or a maximal number of peaks/fragments threshold
      (<code>maxNumber</code>). Please note that the maximal number is transfered to
      an intensity threshold and the result could contain less peaks than
      specified by <code>maxNumber</code>.
      If both arguments are given, the more aggressive one is chosen.
      Use the <code>what</code> argument to specify the data that should be filtered.
      Set <code>what = "fragments.ident"</code> for the identification fragment data
      or <code>what = "spectra.quant"</code> for the quantiation spectra.
      If <code>verbose</code> is <code>TRUE</code> (default) a progress bar is shown.</p></dd>
    <dt>filterUniqueMatches</dt><dd><p><code>signature(object="Synapter", minNumber =
        "numeric")</code>:
      Removes all unique matches that have less than <code>minNumber</code> of
      peaks/fragments in common. Use
      <code>fragmentMatchingPerformance(..., what="unique")</code>/
      <code>plotFragmentMatchingPerformance</code>
      (left panel) to find an ideal threshold.</p></dd>
    <dt>filterNonUniqueMatches</dt><dd><p><code>signature(object="Synapter", minDelta =
        "numeric")</code>:
      Removes all non unique matches that have a difference between the best
      match (highest number of common peaks/fragments, treated as true match)
      and the second best match (second highest number of common
      peaks/fragments) less than <code>minDelta</code>. For the matches above the
      threshold only the one with the highest number of common peaks/fragments
      in each match group is kept.
      Use <code>fragmentMatchingPerformance(..., what="non-unique")</code>/
      <code>plotFragmentMatchingPerformance</code> (right panel) to find an ideal
      threshold.</p></dd>
    <dt>filterNonUniqueIdentMatches</dt><dd><p><code>signature(object="Synapter")</code>:
      Removes all non unique identification matches. In rare circumstances (if
      the grid search parameters are to wide/relaxed or a fragment library is
      used) it could happen that the <code>searchGrid</code> methods matches a single
      quantification EMRT to multiple identification EMRTs. This methods removes
      all these non unique matches.</p></dd>
    </dl>
    <h3>Plotting</h3>
    <dl class='dl-horizontal'>
    <dt>plotPpmError</dt><dd><p><code>signature(object="Synapter", what =
	  "character")</code>: Plots the proportion of data against the mass
	error tolerance in ppms. Depending on <code>what</code>, the data
	for identification (<code>what = "Ident"</code>), quantitation
	(<code>what = "Quant"</code>) or <code>"both"</code> is plotted.</p></dd>
    <dt>plotRtDiffs</dt><dd><p><code>signature(object="Synapter", ...)</code>: Plots
	a histogram of retention time differences after
	alignments. <code>...</code> is passed to <code>hist</code>.</p></dd>
    <dt>plotRt</dt><dd><p><code>signature(object="Synapter", what =
	  "character", f = "numeric", nsd = "numeric")</code>: Plots the
	Identification - Quantitation retention time difference as a
	function of the Identification retention time. If <code>what</code> is
	<code>"data"</code>, two plots are generated: one ranging the full range
	of retention time differences and one focusing on the highest data
	point density and showing models with various <code>span</code>
	parameter values, as defined by <code>f</code> (default is 2/3, 1/2,
	1/4, 1/10, 1/16, 1/25, 1/50, passed as a numed numeric). If
	<code>what</code> is <code>"model"</code>, a focused plot with the applied
	span parameter is plotted and areas of <code>nsd</code> (default is
	<code>x(1, 3, 5)</code> number of standard deviations are shaded around
      the model.</p></dd>
    <dt>plotIntensity</dt><dd><p><code>signature(object="Synapter", what =
	  "character", f = "numeric", nsd = "numeric")</code>: Plots the (log2) ratio
  of Identification and Quantitation intensities as a
	function of the Identification retention time. If <code>what</code> is
	<code>"data"</code>, two plots are generated: one ranging the full range
	of ratios and one focusing on the highest data
	point density and showing models with various <code>span</code>
	parameter values, as defined by <code>f</code> (default is 2/3, 1/2,
	1/4, 1/10, 1/16, 1/25, 1/50, passed as a numed numeric). If
	<code>what</code> is <code>"model"</code>, a focused plot with the applied
	span parameter is plotted and areas of <code>nsd</code> (default is
	<code>x(1, 3, 5)</code> number of standard deviations are shaded around
      the model.</p></dd>
    <dt>plotPepScores</dt><dd><p><code>signature(object="Synapter")</code>: Plots the
      distribution of random and regular peptide scores for
      identification and quantitation features. This reflects how
      peptide p-values are computed. See also <code>getPepNumbers</code>.</p></dd>
    <dt>plotFdr</dt><dd><p><code>signature(object="Synapter", method =
	"character")</code>: Displays 2 plots per identification and
      quantitation peptides, showing the number of significant
      peptides as a function of the FDR cut-off and the expected false
      number of false positive as a number of significant
      tests. PepFrag 1 and 2 peptides are illustrated on the same
      figures. These figures are adapted from <code><a href='http://www.rdocumentation.org/packages/qvalue/topics/plot.qvalue'>plot.qvalue</a></code>.
      <code>method</code>, one of <code>"BH"</code>, <code>"Bonferroni"</code> or
      <code>"qval"</code>, defines what identification statistics to use.</p></dd>
    <dt>plotEMRTtable</dt><dd><p><code>signature(object="Synapter")</code>: Plots
      the barchart of number or 0, 1, 2, ... assigned EMRTs (see
      <code>getEMRTtable</code>) .</p></dd>
    <dt>plotGrid</dt><dd><p><code>signature(object="Synapter", what =
	"character"), maindim = "character"</code>:
      Plots a heatmap of the respective grid search
      results. This grid to be plotted is controlled by <code>what</code>:
      <code>"total"</code>, <code>"model"</code> or <code>"details"</code> are
      available. If ion mobility was used in the grid search you can use
      <code>maindim</code> to decided which dimensions should be shown. <code>maindim</code>
      could be one of <code>"im"</code> (default), <code>"rt"</code> and <code>"mz"</code>. If
      <code>maindim = "im"</code> a heatmap for each ion mobility threshold is drawn.
      For <code>maindim = "rt"</code> and <code>maindim</code> you get a heatmap for each
      retention time respective mass threshold.</p></dd>
    <dt>plotFeatures</dt><dd><p><code>signature(object="Synapter", what =
	"character", xlim = "numeric", ylim = "numeric", ionmobiltiy = "logical")</code>:
      Plots the retention time against precursor mass space.
      If <code>what</code> is <code>"all"</code>, three (six if ion mobility is available
      and <code>ionmobility = TRUE</code> (default is <code>FALSE</code>);
      three additional plots with precursor mass against ion mobility)
      such plots are created side by side: for the
      identification peptides, the quantitation peptides and the
      quantitation Pep3D data. If <code>what</code> is <code>"some"</code>, a
      subset of the rt/mass space can be defined with <code>xlim</code>
      (default is <code>c(40, 60)</code>) and <code>ylim</code> (default is
      <code>c(1160, 1165)</code>) and identification peptide, quantitation
      peptides and EMRTs are presented on the same graph as grey
      dots, blue dots and red crosses respectively. In addition,
      rectangles based on the ppm and nsd defined tolerances (see
      <code>setPpmError</code> and <code>setNsdError</code>) are drawn and
      centered at the expected modelled retention time. This last
      figure allows to visualise the EMRT matching.</p></dd>
    <dt>plotFragmentMatching</dt><dd><p><code>signature(object = "Synapter",
        key = "character", column = "character",
        verbose = "logical", &#8230;)</code>:
      Plots two spectra and fragments against each other. Please see
      <code><a href='plotCrossMatching.html'>plotFragmentMatching</a></code> for details.</p></dd>
    <dt>plotFragmentMatchingPerformance</dt><dd><p><code>signature(object = "Synapter",
        showAllPeptides = FALSE)</code>:
    Creates two plots. The left panel shows the performance of filtering the
    unique matches of the merged peptides using a different number of common
    peaks. The right panel shows the performance of filtering the non unique
    matches of the merged peptides using different differences (delta) in
    common peaks/fragments. These differences (delta) are
    calculated between the match with the highest number of common
    peaks/fragments and the second highest one.
    Use <code>filterUniqueMatches</code> and <code>filterNonUniqueMatches</code> to filter
    the <code>MatchedEMRT</code> <code>data.frame</code> using one of these thresholds.
    This function returns a <code>list</code> with two named elements (<code>unqiue</code>
    and <code>nonunqiue</code> invisibly. These are the same data as return by
    <code>fragmentMatchingPerformance</code>.
    Use <code>showAllPeptides=TRUE</code> to add a line for all peptides (not just
    the merged onces) to both plots.</p></dd>
    <dt>plotCumulativeNumberOfFragments</dt><dd><p><code>signature(object = "Synapter",
        what = c("fragments.ident", "spectra.quant"))</code>:
    Plots the cumulative number of the fragments/peaks vs their intensity (log10
    scaled). Use the <code>what</code> argument to create this plot for the
    identification fragments (<code>what = "fragments.quant"</code>) or the
    the quantitation spectra (<code>what = "spectra.quant"</code>).</p></dd>
  </dl>
    <h3>Exporters</h3>
    <dl class='dl-horizontal'>
      <dt>writeMergedPeptides</dt><dd><p><code>signature(object="Synapter", file
	  = "character", what = "character", ...)</code>: Exports the merged
	peptide data to a comma-separated <code>file</code> (default name is
	<code>"Res-MergedPeptides.csv"</code>).</p></dd>
      <dt>writeMatchedEMRTs</dt><dd><p><code>signature(object="Synapter", file =
	  "character", &#8230;)</code>: As above, saving the
	matched EMRT table.</p></dd>
      <dt>writeIdentPeptides</dt><dd><p><code>signature(object="Synapter", file
	  = "character", &#8230;)</code>: As above, exporting the identification
	peptide data.</p></dd>
      <dt>writeQuantPeptides</dt><dd><p><code>signature(object="Synapter", file
	  = "character", &#8230;)</code>: A above, exporting the quantitation
	peptide data.</p></dd>
      <dt>getIdentificationFragments</dt><dd><p><code>signature(object="Synapter")</code>:
        returns the identification fragments as <code>MSnExp</code>.</p></dd>
      <dt>getQuantitationSpectra</dt><dd><p><code>signature(object="Synapter")</code>:
        returns the quantitation spectra as <code>MSnExp</code>.</p></dd>
    </dl>
    <h3>Other</h3>
    <dl class='dl-horizontal'>
      <dt>as(, "MSnSet")</dt><dd><p><code>signature(x = "Synapter")</code>: Coerce
	object from <code>Synapter</code> to <code>MSnSet</code> class.</p></dd>
    </dl>
    <dl class='dl-horizontal'>
      <dt>validObject</dt><dd><p><code>signature(object = "Synapter")</code>:
        Test whether a given <code>Synapter</code> object is valid.</p></dd>
    </dl>
    <dl class='dl-horizontal'>
      <dt>updateObject</dt><dd><p><code>signature(object = "Synapter")</code>: Updates an old
       <code>Synapter</code> object.</p></dd>
    </dl>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Käll L, Storey JD, MacCoss MJ, Noble WS
  Posterior error probabilities and false discovery rates: two sides of
  the same coin.
  J Proteome Res. 2008a Jan; 7:(1)40-4</p>
<p>Bonferroni single-step adjusted p-values for strong control of the
  FWER.</p>
<p>Benjamini Y. and Hochberg Y.
  Controlling the false discovery rate: a practical and powerful
  approach to multiple testing.
  J. R. Statist. Soc. B., 1995, Vol. 57: 289-300.</p>
<p>Storey JD and Tibshirani R.
  Statistical significance for genome-wide experiments.
  Proceedings of the National Academy of Sciences, 2003, 100: 9440-9445.</p>
<p>Käll, Storey JD, MacCoss MJ, Noble WS
  Assigning significance to peptides identified by tandem mass
  spectrometry using decoy databases.
  J Proteome Res. 2008b Jan; 7:(1)29-34</p>
<p>Improving qualitative and quantitative performance for MSE-based label
  free proteomics, N.J. Bond, P.V. Shliaha, K.S. Lilley and L. Gatto,
  Journal of Proteome Research, 2013, in press.</p>
<p>The Effects of Travelling Wave Ion Mobility Separation on Data
  Independent Acquisition in Proteomics Studies, P.V. Shliaha, N.J. Bond,
  L. Gatto and K.S. Lilley, Journal of Proteome Research, 2013, in press.</p>
    <p>Trypsin cleavage:</p>
<p>Glatter, Timo, et al.
  Large-scale quantitative assessment of different in-solution protein digestion
  protocols reveals superior cleavage efficiency of tandem Lys-C/trypsin
  proteolysis over trypsin digestion.
  Journal of proteome research 11.11 (2012): 5145-5156.
  <a href='http://dx.doi.org/10.1021/pr300273g'>http://dx.doi.org/10.1021/pr300273g</a></p>
<p>Rodriguez, Jesse, et al.
  Does trypsin cut before proline?.
  Journal of proteome research 7.01 (2007): 300-305.
  <a href='http://dx.doi.org/10.1021/pr0705035'>http://dx.doi.org/10.1021/pr0705035</a></p>
<p>Brownridge, Philip, and Robert J. Beynon.
  The importance of the digest: proteolysis and absolute quantification in
  proteomics.
  Methods 54.4 (2011): 351-360.
  <a href='http://dx.doi.org/10.1016/j.ymeth.2011.05.005'>http://dx.doi.org/10.1016/j.ymeth.2011.05.005</a></p>
<p>cleaver's rules are taken from:
  <a href='http://web.expasy.org/peptide_cutter/peptidecutter_enzymes.html#Tryps'>http://web.expasy.org/peptide_cutter/peptidecutter_enzymes.html#Tryps</a></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>library</span>(<span class='no'>synapter</span>) <span class='co'>## always needed</span></div><span class='co'># NOT RUN {</span>
<span class='co'>## (1) Construction - to create your own data objects</span>
<span class='no'>synapterTiny</span> <span class='kw'>&lt;-</span> <span class='fu'>Synapter</span>()
<span class='co'># }</span><div class='input'>
<span class='co'>## let's use synapterTiny, shipped with the package</span>
<span class='fu'><a href='synapterTinyData.html'>synapterTinyData</a></span>() <span class='co'>## loads/prepares the data</span>
<span class='no'>synapterTiny</span> <span class='co'>## show object</span></div><div class='output co'>#&gt; Object of class "Synapter" 
#&gt; Class version 2.0.0 
#&gt; Package version 1.99.0 
#&gt; Data files:
#&gt;  + Identification pep file: 01_HDMSe_tiny.csv 
#&gt;  + Quantitation pep file: 02_MSe_tiny.csv 
#&gt;  + Quantitation Pep3DAMRT file: 03_Pep3D_tiny.csv 
#&gt;  + Fasta file: 04_test_database.fasta 
#&gt; Log:
#&gt; [1] "Instance created on Wed Jun  6 23:37:36 2012"
#&gt; [2] "Read identification peptide data [5915,18]"  
#&gt; [ 9 lines ]
#&gt; [12] "Filtered identification Random entries [4979,22]"
#&gt; [13] "Instance updated to synapter 1.99.0 on Sun Oct 16 16:47:24 2016"</div><div class='input'>
<span class='co'>## (2) Filtering</span>
<span class='co'>## (2.1) Peptide scores and FDR</span>

<span class='co'>## visualise/explore peptide id scores</span>
<span class='fu'>plotPepScores</span>(<span class='no'>synapterTiny</span>)</div><div class='img'><img src='Synapter-1.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>getPepNumbers</span>(<span class='no'>synapterTiny</span>)</div><div class='output co'>#&gt;       PepFrag1.Random PepFrag1.Regular PepFrag2.Random PepFrag2.Regular
#&gt; ident             256             3522             448             1393
#&gt; quant             496             2664             500              745</div><div class='input'>
<span class='co'>## filter data</span>
<span class='fu'>filterUniqueDbPeptides</span>(<span class='no'>synapterTiny</span>) <span class='co'>## keeps unique proteotypic peptides</span>
<span class='fu'>filterPeptideLength</span>(<span class='no'>synapterTiny</span>, <span class='kw'>l</span> <span class='kw'>=</span> <span class='fl'>7</span>) <span class='co'>## default length is 7</span>

<span class='co'>## visualise before FDR filtering</span>
<span class='fu'>plotFdr</span>(<span class='no'>synapterTiny</span>)</div><div class='img'><img src='Synapter-2.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='fu'>setPepScoreFdr</span>(<span class='no'>synapterTiny</span>, <span class='kw'>fdr</span> <span class='kw'>=</span> <span class='fl'>0.01</span>) <span class='co'>## optional</span>
<span class='fu'>filterQuantPepScore</span>(<span class='no'>synapterTiny</span>, <span class='kw'>fdr</span> <span class='kw'>=</span> <span class='fl'>0.01</span>) <span class='co'>## specifying FDR</span>
<span class='fu'>filterIdentPepScore</span>(<span class='no'>synapterTiny</span>) <span class='co'>## FDR not specified, using previously set value</span>

<span class='co'>## (2.2) Mass tolerance</span>
<span class='fu'>getPpmErrorQs</span>(<span class='no'>synapterTiny</span>)</div><div class='output co'>#&gt;         25%   50%   75%   90%   91%   92%   93%   94%    95%    96%    97%
#&gt; Ident 0.982 2.183 4.070 6.750 7.663 8.299 9.136 9.989 12.060 13.997 16.082
#&gt; Quant 0.432 0.972 1.682 3.083 3.341 3.606 3.992 5.021  5.733  6.455  7.736
#&gt;          98%    99%   100%
#&gt; Ident 19.288 22.496 28.664
#&gt; Quant  9.124 14.897 24.599</div><div class='input'><span class='fu'>plotPpmError</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"Ident"</span>)</div><div class='img'><img src='Synapter-3.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>plotPpmError</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"Quant"</span>)</div><div class='img'><img src='Synapter-4.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='fu'>setIdentPpmError</span>(<span class='no'>synapterTiny</span>, <span class='kw'>ppm</span> <span class='kw'>=</span> <span class='fl'>20</span>) <span class='co'>## optional</span>
<span class='fu'>filterQuantPpmError</span>(<span class='no'>synapterTiny</span>, <span class='kw'>ppm</span> <span class='kw'>=</span> <span class='fl'>20</span>)
<span class='co'>## setQuantPpmError(synapterTiny, ppm = 20) ## set quant ppm threshold below</span>
<span class='fu'>filterIdentPpmError</span>(<span class='no'>synapterTiny</span>, <span class='kw'>ppm</span><span class='kw'>=</span><span class='fl'>20</span>)

<span class='fu'>filterIdentProtFpr</span>(<span class='no'>synapterTiny</span>, <span class='kw'>fpr</span> <span class='kw'>=</span> <span class='fl'>0.01</span>)
<span class='fu'>filterQuantProtFpr</span>(<span class='no'>synapterTiny</span>, <span class='kw'>fpr</span> <span class='kw'>=</span> <span class='fl'>0.01</span>)

<span class='fu'>getPpmErrorQs</span>(<span class='no'>synapterTiny</span>) <span class='co'>## to be compared with previous output</span></div><div class='output co'>#&gt;         25%   50%   75%   90%   91%   92%   93%   94%   95%    96%    97%
#&gt; Ident 0.968 2.144 3.939 6.233 6.589 7.035 7.942 8.775 9.523 10.688 12.643
#&gt; Quant 0.431 0.964 1.661 2.973 3.137 3.386 3.702 4.214 5.211  6.095  7.117
#&gt;          98%    99%   100%
#&gt; Ident 14.563 17.007 19.744
#&gt; Quant  8.289  9.558 19.817</div><div class='input'>
<span class='co'>## (3) Merge peptide sequences</span>
<span class='fu'>mergePeptides</span>(<span class='no'>synapterTiny</span>)

<span class='co'>## (4) Retention time modelling</span>
<span class='fu'>plotRt</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"data"</span>)</div><div class='img'><img src='Synapter-5.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>setLowessSpan</span>(<span class='no'>synapterTiny</span>, <span class='fl'>0.05</span>)
<span class='fu'>modelRt</span>(<span class='no'>synapterTiny</span>) <span class='co'>## the actual modelling</span>
<span class='fu'>getRtQs</span>(<span class='no'>synapterTiny</span>)</div><div class='output co'>#&gt;    25%    50%    75%    90%    91%    92%    93%    94%    95%    96%    97% 
#&gt;  0.003  0.008  0.016  0.029  0.031  0.034  0.040  0.047  0.057  0.072  0.463 
#&gt;    98%    99%   100% 
#&gt;  4.161 10.703 32.140 </div><div class='input'><span class='fu'>plotRtDiffs</span>(<span class='no'>synapterTiny</span>)</div><div class='img'><img src='Synapter-6.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'>## plotRtDiffs(synapterTiny, xlim=c(-1, 1), breaks=500) ## pass parameters to hist()</span>
<span class='fu'>plotRt</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"model"</span>) <span class='co'>## using default nsd 1, 3, 5</span></div><div class='img'><img src='Synapter-7.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>plotRt</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"model"</span>, <span class='kw'>nsd</span><span class='kw'>=</span><span class='fl'>0.5</span>) <span class='co'>## better focus on model</span></div><div class='img'><img src='Synapter-8.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='fu'>plotFeatures</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"all"</span>)</div><div class='img'><img src='Synapter-9.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>setRtNsd</span>(<span class='no'>synapterTiny</span>, <span class='fl'>3</span>)     <span class='co'>## RtNsd and PpmError are used for detailed plot</span>
<span class='fu'>setPpmError</span>(<span class='no'>synapterTiny</span>, <span class='fl'>10</span>) <span class='co'>## if not set manually, default values are set automatically</span>
<span class='fu'>plotFeatures</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span><span class='kw'>=</span><span class='st'>"some"</span>, <span class='kw'>xlim</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>36</span>,<span class='fl'>44</span>), <span class='kw'>ylim</span><span class='kw'>=</span><span class='fu'>c</span>(<span class='fl'>1161.4</span>, <span class='fl'>1161.7</span>))</div><div class='img'><img src='Synapter-10.png' alt='' width='700' height='433' /></div><div class='input'><span class='co'>## best plotting to svg for zooming</span>

<span class='fu'>set.seed</span>(<span class='fl'>1</span>) <span class='co'>## only for reproducibility of this example</span>

<span class='co'>## (5) Grid search to optimise EMRT matching parameters</span>
<span class='fu'>searchGrid</span>(<span class='no'>synapterTiny</span>,
           <span class='kw'>ppms</span> <span class='kw'>=</span> <span class='fl'>7</span>:<span class='fl'>10</span>,  <span class='co'>## default values are 5, 7, ..., 20</span>
           <span class='kw'>nsds</span> <span class='kw'>=</span> <span class='fl'>1</span>:<span class='fl'>3</span>,   <span class='co'>## default values are 0.5, 1,  ..., 5</span>
           <span class='kw'>subset</span> <span class='kw'>=</span> <span class='fl'>0.2</span>) <span class='co'>## default is 1</span>
<span class='co'>## alternatively, use 'n = 1000' to use exactly</span>
<span class='co'>## 1000 randomly selected features for the grid search</span>
<span class='fu'>getGrid</span>(<span class='no'>synapterTiny</span>)  <span class='co'>## print the grid</span></div><div class='output co'>#&gt; $prcntTotal
#&gt; , , Inf
#&gt; 
#&gt;       7     8     9    10
#&gt; 1 0.747 0.755 0.760 0.760
#&gt; 2 0.824 0.833 0.839 0.839
#&gt; 3 0.824 0.833 0.839 0.839
#&gt; 
#&gt; 
#&gt; $prcntModel
#&gt; , , Inf
#&gt; 
#&gt;       7     8     9    10
#&gt; 1 0.872 0.872 0.872 0.872
#&gt; 2 0.972 0.972 0.972 0.972
#&gt; 3 0.972 0.972 0.972 0.972
#&gt; 
#&gt; 
#&gt; $details
#&gt; , , Inf
#&gt; 
#&gt;       7     8     9    10
#&gt; 1 0.984 0.984 0.984 0.984
#&gt; 2 0.986 0.986 0.986 0.986
#&gt; 3 0.986 0.986 0.986 0.986
#&gt; 
#&gt; </div><div class='input'><span class='fu'>getGridDetails</span>(<span class='no'>synapterTiny</span>)  <span class='co'>## grid details</span></div><div class='output co'>#&gt; $`1:7:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4  33 251   0 
#&gt; 
#&gt; $`1:8:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4  33 251   0 
#&gt; 
#&gt; $`1:9:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4  33 251   0 
#&gt; 
#&gt; $`1:10:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4  33 251   0 
#&gt; 
#&gt; $`2:7:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`2:8:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`2:9:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`2:10:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`3:7:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`3:8:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`3:9:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; 
#&gt; $`3:10:Inf`
#&gt;  -2  -1   0   1   2 
#&gt;   0   4   4 280   0 
#&gt; </div><div class='input'><span class='fu'>plotGrid</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span> <span class='kw'>=</span> <span class='st'>"total"</span>)   <span class='co'>## plot the grid for total matching</span></div><div class='img'><img src='Synapter-11.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>plotGrid</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span> <span class='kw'>=</span> <span class='st'>"model"</span>)   <span class='co'>## plot the grid for matched modelled feature</span></div><div class='img'><img src='Synapter-12.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>plotGrid</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span> <span class='kw'>=</span> <span class='st'>"details"</span>) <span class='co'>## plot the detail grid</span></div><div class='img'><img src='Synapter-13.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>getBestGridValue</span>(<span class='no'>synapterTiny</span>)  <span class='co'>## return best grid values</span></div><div class='output co'>#&gt; prcntTotal prcntModel    details 
#&gt;  0.8390805  0.9722222  0.9859155 </div><div class='input'><span class='fu'>getBestGridParams</span>(<span class='no'>synapterTiny</span>) <span class='co'>## return parameters corresponding to best values</span></div><div class='output co'>#&gt; $prcntTotal
#&gt;      nsd ppm imdiff
#&gt; [1,]   2   9    Inf
#&gt; [2,]   3   9    Inf
#&gt; [3,]   2  10    Inf
#&gt; [4,]   3  10    Inf
#&gt; 
#&gt; $prcntModel
#&gt;      nsd ppm imdiff
#&gt; [1,]   2   7    Inf
#&gt; [2,]   3   7    Inf
#&gt; [3,]   2   8    Inf
#&gt; [4,]   3   8    Inf
#&gt; [5,]   2   9    Inf
#&gt; [6,]   3   9    Inf
#&gt; [7,]   2  10    Inf
#&gt; [8,]   3  10    Inf
#&gt; 
#&gt; $details
#&gt;      nsd ppm imdiff
#&gt; [1,]   2   7    Inf
#&gt; [2,]   3   7    Inf
#&gt; [3,]   2   8    Inf
#&gt; [4,]   3   8    Inf
#&gt; [5,]   2   9    Inf
#&gt; [6,]   3   9    Inf
#&gt; [7,]   2  10    Inf
#&gt; [8,]   3  10    Inf
#&gt; </div><div class='input'><span class='fu'>setBestGridParams</span>(<span class='no'>synapterTiny</span>, <span class='kw'>what</span> <span class='kw'>=</span> <span class='st'>"auto"</span>) <span class='co'>## sets RtNsd and PpmError according the grid results</span>
<span class='co'>## 'what' could also be "model", "total" or "details"</span>
<span class='co'>## setPpmError(synapterTiny, 12) ## to manually set values</span>
<span class='co'>## setRtNsd(synapterTiny, 2.5)</span>

<span class='co'>## (6) Matching ident peptides and quant EMRTs</span>
<span class='fu'>findEMRTs</span>(<span class='no'>synapterTiny</span>)
<span class='fu'>plotEMRTtable</span>(<span class='no'>synapterTiny</span>)</div><div class='img'><img src='Synapter-14.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'>getEMRTtable</span>(<span class='no'>synapterTiny</span>)</div><div class='output co'>#&gt; 
#&gt;    0    1 
#&gt;  559 2486 </div><div class='input'><span class='fu'>performance</span>(<span class='no'>synapterTiny</span>)
<span class='fu'>performance2</span>(<span class='no'>synapterTiny</span>)

<span class='co'>## (7) Exporting data to csv spreadsheets</span>
<span class='fu'>writeMergedPeptides</span>(<span class='no'>synapterTiny</span>)
<span class='fu'>writeMergedPeptides</span>(<span class='no'>synapterTiny</span>, <span class='kw'>file</span> <span class='kw'>=</span> <span class='st'>"myresults.csv"</span>)
<span class='fu'>writeMatchedEMRTs</span>(<span class='no'>synapterTiny</span>)
<span class='fu'>writeMatchedEMRTs</span>(<span class='no'>synapterTiny</span>, <span class='kw'>file</span> <span class='kw'>=</span> <span class='st'>"myresults2.csv"</span>)
<span class='co'>## These will export the filter peptide data</span>
<span class='fu'>writeIdentPeptides</span>(<span class='no'>synapterTiny</span>, <span class='kw'>file</span> <span class='kw'>=</span> <span class='st'>"myIdentPeptides.csv"</span>)
<span class='fu'>writeQuantPeptides</span>(<span class='no'>synapterTiny</span>, <span class='kw'>file</span> <span class='kw'>=</span> <span class='st'>"myQuantPeptides.csv"</span>)
<span class='co'>## If used right after loading, the non-filted data will be exported</span></div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#details">Details</a></li>

      <li><a href="#methods">Methods</a></li>

      <li><a href="#references">References</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

    <h2>Author</h2>
    Laurent Gatto <a href='mailto:lg390@cam.ac.uk'>lg390@cam.ac.uk</a>
  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Laurent Gatto, Nick J. Bond, Pavel V. Shliaha, Sebastian Gibb.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  

  </body>
</html>

